<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WW&#39;s Studio</title>
  
  
  <link href="https://wangshenghu.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangshenghu.github.io/"/>
  <updated>2022-11-21T08:44:02.055Z</updated>
  <id>https://wangshenghu.github.io/</id>
  
  <author>
    <name>Who Watson</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangshenghu.github.io/2022/11/21/hello-world/"/>
    <id>https://wangshenghu.github.io/2022/11/21/hello-world/</id>
    <published>2022-11-21T08:43:25.000Z</published>
    <updated>2022-11-21T08:44:02.055Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://wangshenghu.github.io/2022/11/21/test/"/>
    <id>https://wangshenghu.github.io/2022/11/21/test/</id>
    <published>2022-11-21T08:35:12.000Z</published>
    <updated>2022-11-21T08:49:58.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="test-mermaid">Test Mermaid</h2><pre class="mermaid">graph TD;  A-->B;  A-->C;  B-->D;  C-->D;</pre><h2 id="test-latex">Test LaTeX</h2><p><span class="math display">\[\begin{equation}\left\{\begin{array}{lr}x=\dfrac{3\pi}{2}(1+2t)\cos(\dfrac{3\pi}{2}(1+2t)), &amp; \\y=s, &amp; 0 \leq s \leq L,|t| \leq1. \\z=\dfrac{3\pi}{2}(1+2t)\sin(\dfrac{3\pi}{2}(1+2t)), &amp;  \end{array}\right.\end{equation}\]</span></p><h2 id="test-floating-elements">Test Floating Elements</h2><p>Nullam et orci eu lorem consequat tincidunt vivamus et sagittis magnased nunc rhoncus condimentum sem. In efficitur ligula tate urna.Maecenas massa vel lacinia pellentesque lorem ipsum dolor.</p><div class="archer-float-right"><p><img src="https://cdn.jsdelivr.net/gh/fi3ework/hexo-theme-archer/source/avatar/Misaka.jpg" alt="this is a float image!"></p></div><p>Nullam et orci eu lorem consequat tincidunt. Vivamus et sagittislibero. Nullam et orci eu lorem consequat tincidunt vivamus et sagittismagna sed nunc rhoncus condimentum sem. In efficitur ligula tateurna.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;test-mermaid&quot;&gt;Test Mermaid&lt;/h2&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph TD;
  A--&gt;B;
  A--&gt;C;
  B--&gt;D;
  C--&gt;D;&lt;/pre&gt;
&lt;h2 id=&quot;test-latex&quot;&gt;Test La</summary>
      
    
    
    
    
    <category term="test" scheme="https://wangshenghu.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>实习经历 - 美购</title>
    <link href="https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-meigo/"/>
    <id>https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-meigo/</id>
    <published>2016-09-06T11:54:13.000Z</published>
    <updated>2022-11-24T11:23:27.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间">时间</h2><p>2016年7月 - 2016年8月 ## 公司 上海淘玺电子商务有限公司（美购网）<span id="more"></span> ## 项目一个小型nginx日志收集处理系统，用于收集美购网的用户行为日志。 ##具体工作为公司的两台nginx日志服务器搭建的一个伪分布式的实时的小型日志收集处理系统，以方便今后的实时日志分析。<br />架构设计采用flume-&gt;kafka-&gt;flume-&gt;hdfs-&gt;hive的形式。<br />两台nginx日志服务器各配置一个flume agent，采用tail-F命令实时收集原始日志作为source，并sink到第三台机器的kafka中间件，然后再接一个flumeagnet，将数据以分钟为单位sink到hdfs。然后采用mapreduce程序对hdfs里的原始数据进行分析，提取键值对，并入库（hive）永久化存储。## 语言技术 语言：Java<br />技术：flume，kafka，hadoop，hive ## 开发及同步工具 开发：linux，vim同步：git</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;时间&quot;&gt;时间&lt;/h2&gt;
&lt;p&gt;2016年7月 - 2016年8月 ## 公司 上海淘玺电子商务有限公司（美购网）</summary>
    
    
    
    <category term="实习经历" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    <category term="项目" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>实习经历 - MSRA</title>
    <link href="https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-msra/"/>
    <id>https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-msra/</id>
    <published>2016-09-06T09:38:18.000Z</published>
    <updated>2022-11-24T11:23:27.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间">时间</h2><p>2015年6月 - 2016年3月 ## 公司 北京微软亚洲研究院 <span id="more"></span> ## 项目<ahref="http://bda-codehow.cloudapp.net/">CodeHow</a>，一个自然语言查询的代码搜索引擎。## 具体工作CodeHow是一个用于自然语言查询的代码搜索工具。目前支持C#、C++、Java、JavaScript。同时它还可用于ApiExample查询。<br />前端采用MVC框架，负责接收用户输入并与后台搜索引擎交互。<br />后台采用<ahref="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>以及SqlServer。其中基于自然语言搜索的代码库使用elasticsearch，而ApiExample部分的代码库使用sql server。<br />代码库源代码收集：Nodejs脚本编写的github爬虫。<br />代码库源代码AST分析：C#和VB采用<ahref="https://roslyn.codeplex.com/">Roslyn</a>以及<ahref="https://www.nuget.org/">Nuget</a>，Java采用jdk，C++采用Clang，JavaScript采用<ahref="http://esprima.org/demo/parse.html">esprima</a>。<br />部分研究工作：通过NLP领域的词向量提取方法（如流行的word2vec）尝试提取软件工程领域的同义词，并应用到代码搜索上以提高搜索精度。## 语言技术 语言：C#，Java，Javascript<br />技术：MVC，AST分析，信息检索，自然语言处理 ##开发及同步工具 开发：VisualStudio 2015/eclipse/sublime 同步：git</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;时间&quot;&gt;时间&lt;/h2&gt;
&lt;p&gt;2015年6月 - 2016年3月 ## 公司 北京微软亚洲研究院</summary>
    
    
    
    <category term="实习经历" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    <category term="项目" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>实习经历 - Intel</title>
    <link href="https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-intel/"/>
    <id>https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-intel/</id>
    <published>2016-09-06T09:08:48.000Z</published>
    <updated>2022-11-24T11:23:27.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间">时间</h2><p>2014年10月 - 2015年6月 ## 公司 上海紫竹intel <span id="more"></span> ## 项目参与开源项目<a href="http://dpdk.org/">DPDK</a>（Data Plane DevelopmentKit）的开发与测试。DPDK是一系列用来支持快速网络包处理的库及驱动。 ##具体工作 DPDK测试用例编写及性能分析，如l3fwd（层三转发）。<br />DPDK中igb driver的rx_queue中断功能。<br />DPDK中对Ethernet+NSH包头的faked encapsulation和faked decapsulation。 ##语言技术 语言：C<br />技术：linux内核驱动 ## 开发及同步工具 开发：vim/gcc 同步：git</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;时间&quot;&gt;时间&lt;/h2&gt;
&lt;p&gt;2014年10月 - 2015年6月 ## 公司 上海紫竹intel</summary>
    
    
    
    <category term="实习经历" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    <category term="项目" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>实习经历 - 大众点评</title>
    <link href="https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-dazhongdianping/"/>
    <id>https://wangshenghu.github.io/2016/09/06/2016-09-06-internship-dazhongdianping/</id>
    <published>2016-09-06T08:48:07.000Z</published>
    <updated>2022-11-24T11:23:27.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间">时间</h2><p>2013年7月 - 2013年9月 ## 公司 上海大众点评 <span id="more"></span> ## 项目项目名称K-Board，为提高公司技术部生产效率设计的一款基于Kinect手势控制的PC白板软件。该软件支持手势控制操作，多媒体元素信息存储等功能。## 具体实现实现选择了UI和手势控制逻辑解耦的方式，白板UI采用html实现，手势控制则用Kinectfor windows sdk。两部分的整合采用WPF/Awesomium。 ## 语言技术语言：C#，html，javascript<br />技术：Kinect for windows sdk ## 开发及同步工具 开发：Notepad++/VisualStudio 2010/Chrome开发者工具<br />同步：SVN</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;时间&quot;&gt;时间&lt;/h2&gt;
&lt;p&gt;2013年7月 - 2013年9月 ## 公司 上海大众点评</summary>
    
    
    
    <category term="实习经历" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
    
    <category term="项目" scheme="https://wangshenghu.github.io/categories/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1295 - 数论二·Eular质数筛法</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-eular-prime-filter/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-eular-prime-filter/</id>
    <published>2016-05-17T11:18:49.000Z</published>
    <updated>2022-11-24T11:23:27.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>求解一个区间[1, N]所有质数的个数。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1295">hihoCoder</a>。<span id="more"></span> ## 解题思路 <strong>Eratosthenes筛法</strong>如果一个数p是质数，那么将它的倍数全部标记为质数。算法时间复杂度是NloglogN。对一个合数的每一个质因子都会计算一遍，造成了大量冗余。<br /><strong>Eular筛法</strong>在筛选时，无论是质数还是合数，都对它们的倍数进行标记，不过仅标记它们的质数倍。此外，在从小到大依次枚举质数p来计算i的倍数时，我们还需要检查i是否能够整除p。若i能够整除p，则停止枚举。这样可以确保每个合数仅被标记一次。时间复杂度为N。## 时间复杂度 如上述，时间复杂度为N。 ## 代码</p><div class="sourceCode" id="cb1"><preclass="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> eularPrime<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">&#123;</span></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span><span class="op">*</span> isPrime <span class="op">=</span> <span class="kw">new</span> <span class="dt">bool</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        isPrime<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span><span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> primeList <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span><span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> primeCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span><span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">&#123;</span></span><span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>isPrime<span class="op">[</span>i<span class="op">])</span> <span class="op">&#123;</span></span><span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            primeCount<span class="op">++;</span></span><span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            primeList<span class="op">[</span>primeCount<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span><span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> primeCount<span class="op">;</span> j<span class="op">++)</span> <span class="op">&#123;</span></span><span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">*</span> primeList<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;</span> n<span class="op">)</span></span><span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span><span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            isPrime<span class="op">[</span>i <span class="op">*</span> primeList<span class="op">[</span>j<span class="op">]]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span><span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> primeList<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span><span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span><span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">&#125;</span></span><span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">&#125;</span></span><span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> primeCount<span class="op">;</span></span><span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span><span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">&#123;</span></span><span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span><span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span><span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> eularPrime<span class="op">(</span>n<span class="op">);</span></span><span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span><span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;</span></span></code></pre></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;求解一个区间[1, N]所有质数的个数。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1295&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1287 - 数论一·Miller-Rabin质数测试</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-miller-rabin/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-miller-rabin/</id>
    <published>2016-05-17T11:00:54.000Z</published>
    <updated>2022-11-24T11:23:27.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定一个数字（很大），判断它是否是质数。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1287">hihoCoder</a>。<span id="more"></span> ## 解题思路<strong>Miller-Rabin质数测试</strong>是基于费马小定理的一个扩展。<br /><strong>费马小定理</strong><code>对于质数p和任意整数a，有a^p ≡ a(mod p)。对于质数p和任意正整数a &lt; p,有a^(p-1) ≡ 1(mod p)</code><br />反过来，<code>如果一个数字p满足对任意正整数a &lt; p,有a^(p-1) ≡ 1(mod p)，那p很有可能是质数。</code>这就是<strong>Fermat测试</strong>。<br /><strong>Miller-Rabin质数测试</strong>在Fermat测试的基础上，增加了一个二次探测定理。<br /><strong>二次探测定理</strong><code>如果p是奇素数，则 x^2 ≡ 1(mod p)的解为 x ≡ 1 或 x ≡ p - 1(mod p)</code><br />如果a^(p-1) ≡ 1(modp)成立，Miller-Rabin算法会检查p-1是否是偶数，如果p-1偶数，那么令u=(p-1)/2，继续检查a^u≡ 1或a^u ≡ n - 1(mod n)是否满足。<br />Miller-Rabin每次测试失误的概率是1/4；进行S次后，失误的概率是4<sup>-S</sup>。<br />如果n &lt; 2<sup>64</sup>，只用选取a=2, 3, 5, 7, 11, 13, 17, 19, 23, 29,31, 37做测试即可。（摘自<ahref="http://www.matrix67.com/blog/archives/234">数论部分第一节：素数与素性测试</a>）## 时间复杂度 进行S次测试的时间复杂度为SlogN。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;ctime&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mulRem</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> a % p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mulRem</span>((a &lt;&lt; <span class="number">1</span>) % p, b &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">return</span> (<span class="built_in">mulRem</span>((a &lt;&lt; <span class="number">1</span>) % p, b &gt;&gt; <span class="number">1</span>, p) + a) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">powRem</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> power, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (power == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (power == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> a % p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((power &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">powRem</span>(<span class="built_in">mulRem</span>(a, a, p), power &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mulRem</span>(<span class="built_in">powRem</span>(<span class="built_in">mulRem</span>(a, a, p), power &gt;&gt; <span class="number">1</span>, p), a, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">minerRabin</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> A[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> u = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((u &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">u = u &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// srand(time(NULL));</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> v = u;</span><br><span class="line"><span class="comment">// long long a = rand() % (n - 2) + 2;</span></span><br><span class="line"><span class="type">int</span> a = A[i];</span><br><span class="line"><span class="keyword">if</span> (a &gt;= n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x = <span class="built_in">powRem</span>(a, v, n);</span><br><span class="line">v = v &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (v &lt; n) &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> y = <span class="built_in">mulRem</span>(x, x, n);</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = y;</span><br><span class="line">v = v &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// long t1 = time(NULL);</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *a = <span class="keyword">new</span> <span class="type">long</span> <span class="type">long</span>[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">cout &lt;&lt; (<span class="built_in">minerRabin</span>(a[i], <span class="number">12</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="comment">// long t2 = time(NULL);</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; t2 - t1 &lt;&lt; &quot;ms&quot;;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个数字（很大），判断它是否是质数。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1287&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1177 - 顺子</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-straight/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-straight/</id>
    <published>2016-05-17T10:49:37.000Z</published>
    <updated>2022-11-24T11:23:27.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>假设已经有4张牌，计算得到下一张牌后是顺子的概率是多少（不包含同花顺）。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1177">hihoCoder</a>。<span id="more"></span> ## 解题思路普通的分情况讨论。记得<strong>仔细，仔细，再仔细</strong>。 ##时间复杂度 时间复杂度为1。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNumber</span><span class="params">(string card, <span class="type">char</span>&amp; color)</span> </span>&#123;</span><br><span class="line">color = card[card.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (card.<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">number = map[card[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">probability</span><span class="params">(string* cards, <span class="type">int</span>&amp; up, <span class="type">int</span>&amp; down)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> numbers[<span class="number">4</span>];</span><br><span class="line"><span class="type">bool</span> sameColor = <span class="literal">true</span>;</span><br><span class="line"><span class="type">char</span> color = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="type">char</span> colorTmp;</span><br><span class="line">numbers[i] = <span class="built_in">getNumber</span>(cards[i], colorTmp);</span><br><span class="line"><span class="keyword">if</span> (color != <span class="string">&#x27; &#x27;</span> &amp;&amp; colorTmp != color)</span><br><span class="line">sameColor = <span class="literal">false</span>;</span><br><span class="line">color = colorTmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> minN = numbers[i];</span><br><span class="line"><span class="type">int</span> minI = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[j] &lt; minN) &#123;</span><br><span class="line">minN = numbers[j];</span><br><span class="line">minI = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">numbers[minI] = numbers[i];</span><br><span class="line">numbers[i] = minN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (numbers[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; (numbers[<span class="number">1</span>] == <span class="number">11</span> &amp;&amp; numbers[<span class="number">2</span>] == <span class="number">12</span> &amp;&amp; numbers[<span class="number">3</span>] == <span class="number">13</span>) ||</span><br><span class="line">(numbers[<span class="number">1</span>] == <span class="number">2</span> &amp;&amp; numbers[<span class="number">2</span>] == <span class="number">3</span> &amp;&amp; numbers[<span class="number">3</span>] == <span class="number">4</span>) || </span><br><span class="line">(numbers[<span class="number">1</span>] == <span class="number">10</span> &amp;&amp; numbers[<span class="number">2</span>] == <span class="number">11</span> &amp;&amp; numbers[<span class="number">3</span>] == <span class="number">12</span>) ||</span><br><span class="line">(numbers[<span class="number">1</span>] == <span class="number">10</span> &amp;&amp; numbers[<span class="number">2</span>] == <span class="number">11</span> &amp;&amp; numbers[<span class="number">3</span>] == <span class="number">13</span>) ||</span><br><span class="line">(numbers[<span class="number">1</span>] == <span class="number">10</span> &amp;&amp; numbers[<span class="number">2</span>] == <span class="number">12</span> &amp;&amp; numbers[<span class="number">3</span>] == <span class="number">13</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (sameColor) &#123;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">down = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">down = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> straight = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (numbers[i + <span class="number">1</span>] - numbers[i] != <span class="number">1</span>) &#123;</span><br><span class="line">straight = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (straight) &#123;</span><br><span class="line"><span class="keyword">if</span> (sameColor) &#123;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">down = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">down = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">bool</span> unStraight = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[i + <span class="number">1</span>] - numbers[i] == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!unStraight)</span><br><span class="line">unStraight = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">unStraight = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (numbers[i + <span class="number">1</span>] - numbers[i] != <span class="number">1</span>) &#123;</span><br><span class="line">unStraight = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unStraight) &#123;</span><br><span class="line"><span class="keyword">if</span> (sameColor) &#123;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">down = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">down = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">up = <span class="number">0</span>;</span><br><span class="line">down = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>((<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + i), i));</span><br><span class="line">map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;J&#x27;</span>, <span class="number">11</span>));</span><br><span class="line">map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;Q&#x27;</span>, <span class="number">12</span>));</span><br><span class="line">map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;K&#x27;</span>, <span class="number">13</span>));</span><br><span class="line">string cards[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">cin &gt;&gt; cards[i];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> up = <span class="number">0</span>, down = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">probability</span>(cards, up, down);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; up &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; down &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;假设已经有4张牌，计算得到下一张牌后是顺子的概率是多少（不包含同花顺）。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1177&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1164 - 随机斐波那契</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-random-fibonacci/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-random-fibonacci/</id>
    <published>2016-05-17T10:35:29.000Z</published>
    <updated>2022-11-24T11:23:27.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>考虑如下生成的斐波那契数列:<br /><code>a[0] = 1, a[i] = a[j] + a[k], i &gt; 0, j, k从[0, i-1]的整数中随机选出（j和k独立）</code><br />现在给定n，要求求出E(a<sub>n</sub>)，即各种可能的a数列中a<sub>n</sub>的期望值。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1164">hihoCoder</a>。<span id="more"></span> ## 解题思路本题其实很简单。考虑期望的定义，可以得到递推式：<br /><code>f[i] = 1/i * sum(f[0], f[1], ..., f[i-1] + 1/i * sum(f[0], f[1], ..., f[i-1]</code>## 时间复杂度 时间复杂度为N，空间复杂度为1。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">randomFib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> sum = <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> fib = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">fib = <span class="number">2</span> * sum / i;</span><br><span class="line">sum += fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">randomFib</span>(n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;考虑如下生成的斐波那契数列:&lt;br /&gt;
&lt;code&gt;a[0] = 1, a[i] = a[j] + a[k], i &amp;gt; 0, j, k从[0, i-1]的整数中随机选出（j和k独立）&lt;/code&gt;&lt;br /&gt;
现在给定n，要求求出E(a&lt;sub&gt;n&lt;/sub&gt;)，即各种可能的a数列中a&lt;sub&gt;n&lt;/sub&gt;的期望值。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1164&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1149 - 回文字符序列</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-palindrome-sub-sequence/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-palindrome-sub-sequence/</id>
    <published>2016-05-17T10:18:05.000Z</published>
    <updated>2022-11-24T11:23:27.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定字符串，求它的回文子序列个数。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1149">hihoCoder</a>。<span id="more"></span> ## 解题思路本题与求最长回文子序列很类似，只要在算法上稍作修改即可。<br />仍然采用动态规划的思想。在求f[i,j]时，注意到包含第i个字符且不包含第j个字符的回文子序列个数为f[i, j-1] -f[i+1, j-1]，包含第j个字符且不包含第i个字符的回文子序列个数为f[i+1, j] -f[i+1, j-1]，均不包含则是f[i+1, j-1]，均包含则是f[i+1, j-1] +1。因此列出递推式：<br /><code>f[i, j] = f[i, j-1] + f[i+1, j] - f[i+1, j-1]  如果str[i] != str[j]</code><br /><code>f[i, j] = f[i, j-1] + f[i+1, j] + 1  如果str[i] == str[j]</code><br /><strong>注意，凡是涉及到动态规划的问题最好都要画出递推进行的矩阵，弄明白起始点和结束点，以及递推方向。</strong>## 时间复杂度时间复杂度为N<sup>2</sup>，空间复杂度为N<sup>2</sup>，可进一步优化为2N。## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calSum</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = str.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span>** S = <span class="keyword">new</span> <span class="type">int</span>*[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">S[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">S[i][j] = <span class="number">0</span>;</span><br><span class="line">S[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">S[i][j] = (S[i + <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j])</span><br><span class="line">S[i][j] += S[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">S[i][j] = (S[i][j] + <span class="number">100007</span>) % <span class="number">100007</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> S[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= T; i++) &#123;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">calSum</span>(str) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定字符串，求它的回文子序列个数。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1149&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1141 - 二分·归并排序之逆序对</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search-reversed-pair/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search-reversed-pair/</id>
    <published>2016-05-17T09:26:02.000Z</published>
    <updated>2022-11-24T11:23:27.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定一个数组，求该数组中逆序对的个数。如果两个元素a，b满足a在b的前面，但a&gt; b，则(a, b)是一个逆序对。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1141">hihoCoder</a>。<span id="more"></span> ## 解题思路 采用MergeSort的思想，考察在一次merge的过程中，可以直接将参与merge的两个数组之间的逆序对统计出来（即merge进行中每次插入左边数组的一个元素时，所有已插入的右边数组的元素都与其构成一个逆序对）。## 时间复杂度 时间复杂度为NlogN。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> pairs = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* B = <span class="keyword">new</span> <span class="type">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> i = start, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] &lt;= A[j]) &#123;</span><br><span class="line">B[k++] = A[i++];</span><br><span class="line">pairs += j - mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">B[k++] = A[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">B[k++] = A[i++];</span><br><span class="line">pairs += end - mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= end)</span><br><span class="line">B[k++] = A[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = start; i &lt;= end; i++)</span><br><span class="line">A[i] = B[i - start];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pairs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>* A, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == end)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> left = <span class="built_in">sort</span>(A, start, mid);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> right = <span class="built_in">sort</span>(A, mid + <span class="number">1</span>, end);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> pairs = <span class="built_in">merge</span>(A, start, end, mid);</span><br><span class="line"><span class="keyword">return</span> pairs + left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="type">int</span>* A = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">cin &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sort</span>(A, <span class="number">0</span>, N - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个数组，求该数组中逆序对的个数。如果两个元素a，b满足a在b的前面，但a
&amp;gt; b，则(a, b)是一个逆序对。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1141&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1139 - 二分·二分答案</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search-answer/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search-answer/</id>
    <published>2016-05-17T08:19:44.000Z</published>
    <updated>2022-11-24T11:23:27.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>在游戏《艦これ》中，海域是N个战略点(编号1..N)组成，如下图所示<br /><img src="/images/hihocoder-binary-search-answer-1.png" class=""><br />其中红色的点表示有敌人驻扎，猫头像的的点表示该地图敌军主力舰队(boss)的驻扎点，虚线表示各个战略点之间的航线(无向边)。在游戏中要从一个战略点到相邻战略点需要满足一定的条件，即需要舰队的索敌值大于等于这两点之间航线的索敌值需求。由于提高索敌值需要将攻击机、轰炸机换成侦察机，舰队索敌值越高，也就意味着舰队的战力越低。另外在每一个战略点会发生一次战斗，需要消耗1/K的燃料和子弹。必须在燃料和子弹未用完的情况下进入boss点才能与boss进行战斗，所以舰队最多只能走过K条航路。现在Nettle想要以最高的战力来进攻boss点，所以他希望能够找出一条从起始点(编号为1的点)到boss点的航路，使得舰队需要达到的索敌值最低，并且有剩余的燃料和子弹。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1139">hihoCoder</a>。<span id="more"></span> ## 解题思路本题的关键在于解的大小范围是可预知的，即所有边中最小的索敌值与最大的索敌值这个区间。因此可以采用二分求解，枚举一个解，并检查是否是可行解，再二分区间缩小范围。## 时间复杂度 检查采用的是BFS，时间复杂度为N，因此整体时间复杂度为Nlog(R- L)（L、R分别为最短边长及最大边长）。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; neighbors;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bitset&lt;10001&gt; set;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(Node* graph, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> k, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">visited.<span class="built_in">push</span>(s);</span><br><span class="line">level.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!visited.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> root = visited.<span class="built_in">front</span>();</span><br><span class="line">visited.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> l = level.<span class="built_in">front</span>();</span><br><span class="line">level.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (l &gt; k)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root == t)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[root].neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!set[graph[root].neighbors[i]]) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[root].edges[i] &lt;= w) &#123;</span><br><span class="line">set[graph[root].neighbors[i]] = <span class="number">1</span>;</span><br><span class="line">visited.<span class="built_in">push</span>(graph[root].neighbors[i]);</span><br><span class="line">level.<span class="built_in">push</span>(l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sat</span><span class="params">(Node* graph, <span class="type">int</span> t, <span class="type">int</span> k, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">set.<span class="built_in">reset</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bfs</span>(graph, <span class="number">1</span>, t, k, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calMin</span><span class="params">(Node* graph, <span class="type">int</span> t, <span class="type">int</span> k, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left + <span class="number">1</span> == right)</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sat</span>(graph, t, k, mid))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calMin</span>(graph, t, k, left, mid);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calMin</span>(graph, t, k, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, M = <span class="number">0</span>, K = <span class="number">0</span>, T = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; T;</span><br><span class="line">Node* graph = <span class="keyword">new</span> Node[N + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> minW = <span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> maxW = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">graph[a].neighbors.<span class="built_in">push_back</span>(b);</span><br><span class="line">graph[a].edges.<span class="built_in">push_back</span>(w);</span><br><span class="line">graph[b].neighbors.<span class="built_in">push_back</span>(a);</span><br><span class="line">graph[b].edges.<span class="built_in">push_back</span>(w);</span><br><span class="line">maxW = <span class="built_in">max</span>(maxW, w);</span><br><span class="line">minW = <span class="built_in">min</span>(minW, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">calMin</span>(graph, T, K, minW, maxW) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;在游戏《艦これ》中，海域是N个战略点(编号1..N)组成，如下图所示&lt;br /&gt;
&lt;img src=&quot;/images/hihocoder-binary-search-answer-1.png&quot; class=&quot;&quot;&gt;&lt;br /&gt;
其中红色的点表示有敌人驻扎，猫头像的的点表示该地图敌军主力舰队(boss)的驻扎点，虚线表示各个战略点之间的航线(无向边)。
在游戏中要从一个战略点到相邻战略点需要满足一定的条件，即需要舰队的索敌值大于等于这两点之间航线的索敌值需求。
由于提高索敌值需要将攻击机、轰炸机换成侦察机，舰队索敌值越高，也就意味着舰队的战力越低。
另外在每一个战略点会发生一次战斗，需要消耗1/K的燃料和子弹。必须在燃料和子弹未用完的情况下进入boss点才能与boss进行战斗，所以舰队最多只能走过K条航路。
现在Nettle想要以最高的战力来进攻boss点，所以他希望能够找出一条从起始点(编号为1的点)到boss点的航路，使得舰队需要达到的索敌值最低，并且有剩余的燃料和子弹。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1139&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1133 - 二分·二分查找之k小数</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search-kth/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search-kth/</id>
    <published>2016-05-17T08:13:20.000Z</published>
    <updated>2022-11-24T11:23:27.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定一个数组，求排好序的该数组中第k小的数。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1133">hihoCoder</a>。<span id="more"></span> ## 解题思路二分查找。采用类似快排里split的思想，每次计算数组第一个元素在排好序的该数组中的位置，并且判断该位置与k的大小关系，进行二分。## 时间复杂度类似快排，平均情况下时间复杂度为NlogN。最坏情况是N<sup>2</sup>。 ## 代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = start;</span><br><span class="line"><span class="type">int</span> x = array[start];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= end; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[j] &lt; x) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="type">int</span> tmp = array[i];</span><br><span class="line">array[i] = array[j];</span><br><span class="line">array[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">array[start] = array[i];</span><br><span class="line">array[i] = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid = <span class="built_in">split</span>(array, start, end);</span><br><span class="line"><span class="keyword">if</span> (k == mid)</span><br><span class="line"><span class="keyword">return</span> array[mid];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (k &lt; mid)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">search</span>(array, start, mid - <span class="number">1</span>, k);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">search</span>(array, mid + <span class="number">1</span>, end, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> N, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; N)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">search</span>(array, <span class="number">0</span>, N - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; k;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">cin &gt;&gt; array[i];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">find</span>(array, N, k) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个数组，求排好序的该数组中第k小的数。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1133&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1128 - 二分·二分查找</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-binary-search/</id>
    <published>2016-05-17T08:01:15.000Z</published>
    <updated>2022-11-24T11:23:27.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定一个数组，求一个数字K在排好序的该数组中哪个位置。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1128">hihoCoder</a>。<span id="more"></span> ## 解题思路二分查找。采用类似快排里split的思想，将K插入数组最后一个位置并运行一遍split函数找到K在排好序的该数组中的位置，然后只要检查在K右侧的数字里是否有等于K的数即可。## 时间复杂度 split函数用时N，检查一遍用时N，整体时间复杂度为2N。 ##代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = end;</span><br><span class="line"><span class="type">int</span> x = array[end];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= start; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[j] &gt;= x) &#123;</span><br><span class="line">i--;</span><br><span class="line"><span class="type">int</span> tmp = array[j];</span><br><span class="line">array[j] = array[i];</span><br><span class="line">array[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">array[end] = array[i];</span><br><span class="line">array[i] = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid = <span class="built_in">split</span>(array, <span class="number">0</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">if</span> (array[i] == array[mid])</span><br><span class="line"><span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, K = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">cin &gt;&gt; array[i];</span><br><span class="line">array[N] = K;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">find</span>(array, N) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个数组，求一个数字K在排好序的该数组中哪个位置。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1128&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1127 - 二分图三·二分图最小点覆盖和最大独立集</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-vertex-cover/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-vertex-cover/</id>
    <published>2016-05-17T05:48:13.000Z</published>
    <updated>2022-11-24T11:23:27.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>顶点覆盖是一些顶点（或边）的集合，使得图中的每一条边（每一个顶点）都至少接触集合中的一个顶点（边）。<br />独立集是指图中两两互不相邻的顶点构成的集合。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1127">hihoCoder</a>。<span id="more"></span> ## 解题思路 <strong>König定理</strong>一个二分图中的最大匹配数等于这个图中的最小点覆盖数。<br />一个图的最小点覆盖数 = V - 最大独立集<br /><strong>匈牙利算法</strong> 求解二分图最大匹配问题。<br /><strong>核心思想</strong>从二分图中找出一条路径来，让路径的起点和终点都是还没有匹配过的点，并且路径经过的连线是一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现。找到这样的路径后，显然路径里没被匹配的连线比已经匹配了的连线多一条，于是修改匹配图，把路径里所有匹配过的连线去掉匹配关系，把没有匹配的连线变成匹配的，这样匹配数就比原来多1个。（摘自<ahref="http://www.matrix67.com/blog/archives/39">二分图最大匹配问题匈牙利算法</a>）## 时间复杂度最坏情况下，每次新增一个顶点时每条边都要检查一次，时间复杂度为MN。 ##代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> color = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> to = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; neighbors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bitset&lt;1001&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(Node* graph, <span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[node].neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[graph[node].neighbors[i]]) &#123;</span><br><span class="line">visited[graph[node].neighbors[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (graph[graph[node].neighbors[i]].to == <span class="number">0</span> || <span class="built_in">find</span>(graph, graph[graph[node].neighbors[i]].to)) &#123;</span><br><span class="line">graph[graph[node].neighbors[i]].to = node;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bigraph</span><span class="params">(Node* graph, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">graph[root].color = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">queue.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> cur = queue.<span class="built_in">front</span>();</span><br><span class="line">queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[cur].neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[graph[cur].neighbors[i]].color == <span class="number">-1</span>) &#123;</span><br><span class="line">graph[graph[cur].neighbors[i]].color = <span class="number">1</span> - graph[cur].color;</span><br><span class="line">queue.<span class="built_in">push</span>(graph[cur].neighbors[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">if</span> (graph[i].color == <span class="number">-1</span>) &#123;</span><br><span class="line">root = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (root &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hungarian</span><span class="params">(Node* graph, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="built_in">bigraph</span>(graph, N);</span><br><span class="line"><span class="type">int</span> minVertex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (graph[i].color) &#123;</span><br><span class="line">visited.<span class="built_in">reset</span>();</span><br><span class="line">minVertex += <span class="built_in">find</span>(graph, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minVertex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, M = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">Node* graph = <span class="keyword">new</span> Node[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">graph[a].neighbors.<span class="built_in">push_back</span>(b);</span><br><span class="line">graph[b].neighbors.<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minV = <span class="built_in">hungarian</span>(graph, N);</span><br><span class="line">cout &lt;&lt; minV &lt;&lt; endl &lt;&lt; N - minV &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;顶点覆盖是一些顶点（或边）的集合，使得图中的每一条边（每一个顶点）都至少接触集合中的一个顶点（边）。&lt;br /&gt;
独立集是指图中两两互不相邻的顶点构成的集合。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1127&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1115 - 诺兹多姆</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-nozdormu/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-nozdormu/</id>
    <published>2016-05-17T04:52:46.000Z</published>
    <updated>2022-11-24T11:23:27.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>相关链接：<ahref="http://hs.blizzard.cn/landing">炉石传说官网</a><br />某局游戏中，对面上了个诺兹多姆并上了嘲讽和圣盾。诺兹多姆是一个有8点攻击力和8点生命值的随从，这意味着他能够承受总量小于8点的伤害而不死亡，且对于任何攻击他的单位造成8点伤害。嘲讽意味着当诺兹多姆死亡之前你不能攻击对方玩家。圣盾意味着诺兹多姆受到的第一次伤害为0，然后诺兹多姆失去圣盾。<br />你的场上有一些随从，每个随从有其攻击力和生命值，含义同上。同时一些随从也具有圣盾。一些随从还具有风怒，使得他若在第一次攻击后存活，则还能够攻击一次。<br />计算出这回合你能带给对方玩家多少伤害。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1115">hihoCoder</a>。<span id="more"></span> ## 解题思路实际上还是采用穷搜的思路，只是具体实现有些小技巧。采用递归实现的代码比较简单清晰。## 时间复杂度最坏情况下，每一个随从都具有风怒和圣盾（或生命值大于8），那么每次都需要3次递归，这样整体时间复杂度大约是3<sup>7</sup>，是一个常数。## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MIN_VALUE = <span class="number">-999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Minion</span> &#123;</span><br><span class="line"><span class="type">int</span> att = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> hp = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> D = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> W = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxHarm</span><span class="params">(Minion* minions, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> res, <span class="type">bool</span> first)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == n) &#123;</span><br><span class="line"><span class="keyword">if</span> (res &gt;= <span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxH = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line"><span class="keyword">if</span> (minions[i].W &amp;&amp; minions[i].D || minions[i].hp &gt; <span class="number">8</span>)</span><br><span class="line">maxH = <span class="built_in">max</span>(<span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res, <span class="literal">false</span>) + minions[i].att,</span><br><span class="line"><span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res + minions[i].att, <span class="literal">false</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">maxH = <span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (minions[i].W) &#123;</span><br><span class="line">maxH = <span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res, <span class="literal">false</span>) + minions[i].att * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (minions[i].D || minions[i].hp &gt; <span class="number">8</span>) &#123;</span><br><span class="line">maxH = <span class="built_in">max</span>(maxH, <span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res + minions[i].att, <span class="literal">false</span>) + minions[i].att);</span><br><span class="line">maxH = <span class="built_in">max</span>(maxH, <span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res + minions[i].att * <span class="number">2</span>, <span class="literal">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">maxH = <span class="built_in">max</span>(maxH, <span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res + minions[i].att, <span class="literal">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">maxH = <span class="built_in">max</span>(<span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res, <span class="literal">false</span>) + minions[i].att,</span><br><span class="line"><span class="built_in">maxHarm</span>(minions, n, i + <span class="number">1</span>, res + minions[i].att, <span class="literal">false</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">Minion* minions = <span class="keyword">new</span> Minion[n];</span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">getline</span>(cin, line);</span><br><span class="line"><span class="function">istringstream <span class="title">sin</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="type">int</span> att = <span class="number">0</span>, hp = <span class="number">0</span>, d = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">sin &gt;&gt; att &gt;&gt; hp;</span><br><span class="line">minions[i].att = att;</span><br><span class="line">minions[i].hp = hp;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (sin &gt;&gt; c) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">minions[i].D = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">minions[i].W = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxH = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">swap</span>(minions[<span class="number">0</span>], minions[i]);</span><br><span class="line">maxH = <span class="built_in">max</span>(maxH, <span class="built_in">maxHarm</span>(minions, n, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; maxH &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] minions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;相关链接：&lt;a
href=&quot;http://hs.blizzard.cn/landing&quot;&gt;炉石传说官网&lt;/a&gt;&lt;br /&gt;
某局游戏中，对面上了个诺兹多姆并上了嘲讽和圣盾。诺兹多姆是一个有8点攻击力和8点生命值的随从，这意味着他能够承受总量小于8点的伤害而不死亡，且对于任何攻击他的单位造成8点伤害。嘲讽意味着当诺兹多姆死亡之前你不能攻击对方玩家。圣盾意味着诺兹多姆受到的第一次伤害为0，然后诺兹多姆失去圣盾。&lt;br /&gt;
你的场上有一些随从，每个随从有其攻击力和生命值，含义同上。同时一些随从也具有圣盾。一些随从还具有风怒，使得他若在第一次攻击后存活，则还能够攻击一次。&lt;br /&gt;
计算出这回合你能带给对方玩家多少伤害。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1115&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1109 - 最小生成树三·堆优化的Prim算法</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-prim-by-heap/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-prim-by-heap/</id>
    <published>2016-05-17T04:41:05.000Z</published>
    <updated>2022-11-24T11:23:27.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定一个无向图，求最小生成树。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1109">hihoCoder</a>。<span id="more"></span> ## 解题思路 这是采用堆实现的Prim算法（与<ahref="/blog/2016/05/16/hihocoder-dijkstra/">Dijkstra算法</a>十分相似）。<ahref="/blog/2016/05/16/hihocoder-prim/">这里</a>是Prim算法朴素的实现。## 时间复杂度 时间复杂度为MlogN。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HeapNode</span> &#123;</span><br><span class="line"><span class="type">int</span> id = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">HeapNode</span>(<span class="type">int</span> i, <span class="type">int</span> di) &#123;</span><br><span class="line">id = i;</span><br><span class="line">d = di;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> id = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">-1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; neighbors;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NodeCmp</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> HeapNode&amp; a, <span class="type">const</span> HeapNode&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(Node* graph, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">bitset&lt;100001&gt; set;</span><br><span class="line">set.<span class="built_in">reset</span>();</span><br><span class="line">priority_queue&lt;HeapNode, vector&lt;HeapNode&gt;, NodeCmp&gt; heap;</span><br><span class="line">graph[<span class="number">1</span>].d = <span class="number">0</span>;</span><br><span class="line">set[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[<span class="number">1</span>].neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">graph[graph[<span class="number">1</span>].neighbors[i]].d = graph[<span class="number">1</span>].edges[i];</span><br><span class="line">heap.<span class="built_in">push</span>(<span class="built_in">HeapNode</span>(graph[<span class="number">1</span>].neighbors[i], graph[graph[<span class="number">1</span>].neighbors[i]].d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minCost = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N - <span class="number">1</span>) &#123;</span><br><span class="line">HeapNode shortestNode = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (set[shortestNode.id])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">i++;</span><br><span class="line">set[shortestNode.id] = <span class="number">1</span>;</span><br><span class="line">minCost += shortestNode.d;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph[shortestNode.id].neighbors.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (set[graph[shortestNode.id].neighbors[j]])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (graph[graph[shortestNode.id].neighbors[j]].d == <span class="number">-1</span> || graph[shortestNode.id].edges[j] &lt; graph[graph[shortestNode.id].neighbors[j]].d)</span><br><span class="line">graph[graph[shortestNode.id].neighbors[j]].d = graph[shortestNode.id].edges[j];</span><br><span class="line">heap.<span class="built_in">push</span>(<span class="built_in">HeapNode</span>(graph[graph[shortestNode.id].neighbors[j]].id, graph[graph[shortestNode.id].neighbors[j]].d));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, M = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">Node* graph = <span class="keyword">new</span> Node[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++)</span><br><span class="line">graph[i].id = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, edge = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;</span><br><span class="line">graph[a].neighbors.<span class="built_in">push_back</span>(b);</span><br><span class="line">graph[a].edges.<span class="built_in">push_back</span>(edge);</span><br><span class="line">graph[b].neighbors.<span class="built_in">push_back</span>(a);</span><br><span class="line">graph[b].edges.<span class="built_in">push_back</span>(edge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">prim</span>(graph, N) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个无向图，求最小生成树。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1109&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1105 - 题外话·堆</title>
    <link href="https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-heap/"/>
    <id>https://wangshenghu.github.io/2016/05/17/2016-05-17-hihocoder-heap/</id>
    <published>2016-05-17T04:27:54.000Z</published>
    <updated>2022-11-24T11:23:27.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>在许多算法中需要支持下面两种运算的数据结构：插入元素和寻找最大值（最小值）元素。支持这两种运算的数据结构称为优先队列。优先队列的有效实现是采用一种称为堆的简单数据结构。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1105">hihoCoder</a>。<span id="more"></span> ## 解题思路经典数据结构堆的实现。为方便处理，存储元素的数组下标从1开始。 ##时间复杂度 插入、删除操作均为logN。 ## 代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = tmp;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &gt;&gt; <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[i &gt;&gt; <span class="number">1</span>] &lt; data[i])</span><br><span class="line"><span class="built_in">swap</span>(i &gt;&gt; <span class="number">1</span>, i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">i &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;&lt; <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= N &amp;&amp; data[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] &gt; data[i &lt;&lt; <span class="number">1</span>])</span><br><span class="line">i = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (data[i] &gt; data[i &gt;&gt; <span class="number">1</span>])</span><br><span class="line"><span class="built_in">swap</span>(i, i &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Heap</span>() &#123;</span><br><span class="line">data.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">N = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">N++;</span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">size</span>() &lt; N + <span class="number">1</span>)</span><br><span class="line">data.<span class="built_in">push_back</span>(d);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">data[N] = d;</span><br><span class="line"><span class="built_in">siftUp</span>(N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(<span class="number">1</span>, N);</span><br><span class="line"><span class="type">int</span> maxD = data[N];</span><br><span class="line">N--;</span><br><span class="line"><span class="built_in">siftDown</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> maxD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">Heap heap;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">heap.<span class="built_in">insert</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">cout &lt;&lt; heap.<span class="built_in">deleteMax</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;在许多算法中需要支持下面两种运算的数据结构：插入元素和寻找最大值（最小值）元素。支持这两种运算的数据结构称为优先队列。优先队列的有效实现是采用一种称为堆的简单数据结构。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1105&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>hihoCoder#1098 - Kruskal算法</title>
    <link href="https://wangshenghu.github.io/2016/05/16/2016-05-16-hihocoder-kruscal/"/>
    <id>https://wangshenghu.github.io/2016/05/16/2016-05-16-hihocoder-kruscal/</id>
    <published>2016-05-16T12:24:40.000Z</published>
    <updated>2022-11-24T11:23:27.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>给定一个无向图，求最小生成树。<br />具体描述请见<ahref="http://hihocoder.com/problemset/problem/1098">hihoCoder</a>。<span id="more"></span> ## 解题思路 经典的Kruskal算法。<br />1. 对图中的边以非降序排列；<br />2. 对排好序的每条边，如果加入最小生成树不会形成环（采用<ahref="/blog/2016/05/15/hihocoder-union-set/">Union-FindSet</a>实现），则加入最小生成树。 ## 时间复杂度 时间复杂度为MlogM。 ##代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FindUnionSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span>* nodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FindUnionSet</span>(<span class="type">int</span> N) &#123;</span><br><span class="line">nodes = <span class="keyword">new</span> <span class="type">int</span>[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">nodes[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">FindUnionSet</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nodes[node] == node)</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">nodes[node] = <span class="built_in">find</span>(nodes[node]);</span><br><span class="line"><span class="keyword">return</span> nodes[node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionset</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">nodes[<span class="built_in">find</span>(nodes[a])] = <span class="built_in">find</span>(nodes[b]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">edgesCmp</span><span class="params">(<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.length &lt; b.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">(vector&lt;Edge&gt; edges, <span class="type">int</span> N, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), edgesCmp);</span><br><span class="line">FindUnionSet set = <span class="built_in">FindUnionSet</span>(N);</span><br><span class="line"><span class="type">int</span> minCost = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (set.<span class="built_in">find</span>(edges[k].a) != set.<span class="built_in">find</span>(edges[k].b)) &#123;</span><br><span class="line">set.<span class="built_in">unionset</span>(edges[k].a, edges[k].b);</span><br><span class="line">minCost += edges[k].length;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, M = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">vector&lt;Edge&gt; edges = <span class="built_in">vector</span>&lt;Edge&gt;(M);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, edge = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;</span><br><span class="line">edges[i].a = a;</span><br><span class="line">edges[i].b = b;</span><br><span class="line">edges[i].length = edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">kruskal</span>(edges, N, M) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个无向图，求最小生成树。&lt;br /&gt;
具体描述请见&lt;a
href=&quot;http://hihocoder.com/problemset/problem/1098&quot;&gt;hihoCoder&lt;/a&gt;。</summary>
    
    
    
    <category term="算法" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="hihoCoder" scheme="https://wangshenghu.github.io/categories/%E7%AE%97%E6%B3%95/hihoCoder/"/>
    
    
  </entry>
  
</feed>
