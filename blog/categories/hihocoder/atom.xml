<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hihocoder | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/hihocoder/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-12T21:41:59+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1043 - 完全背包]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-complete-backpack/"/>
    <updated>2016-05-12T21:09:55+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-complete-backpack</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>经典完全背包问题。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1043">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>动态规划。递推式为：<br/>
<code>f[i, j] = max(f[i-1, j-C[i]*k] + V[i]*k)，其中0 &lt;= k &lt;= j/V[i]</code><br/>
注意到<code>f[i, j-V[i]] = max(f[i-1, j-C[i]*k] + V[i]*(k-1))，其中1 &lt;= k &lt;= j/V[i]</code>，该递推式可进一步简化：<br/>
<code>f[i, j] = max(f[i, j-V[i]] + V[i], f[i-1, j])</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为MN，空间复杂度为2M，可进一步优化到M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxValue(int* needs, int* values, int N, int M) {
    int** V = new int*[2];
    for (int i = 0; i &lt; 2; i++)
        V[i] = new int[M + 1];

    for (int i = 0; i &lt; M + 1; i++)
        V[0][i] = 0;
    int curLine = 1;
    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; M + 1; j++) {
            if (needs[i] &lt;= j)
                V[curLine][j] = max(V[curLine][j - needs[i]] + values[i], V[1 - curLine][j]);
            else
                V[curLine][j] = V[1 - curLine][j];
        }
        curLine = 1 - curLine;
    }

    int maxV = V[1 - curLine][M];

    for (int i = 0; i &lt; 2; i++)
        delete[] V[i];
    delete[] V;

    return maxV;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    int *needs = new int[N], *values = new int[N];
    for (int i = 0; i &lt; N; i++)
        cin &gt;&gt; needs[i] &gt;&gt; values[i];

    cout &lt;&lt; maxValue(needs, values, N, M) &lt;&lt; endl;

    delete[] needs, values;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1041 - 国庆出游]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-city-travel/"/>
    <updated>2016-05-12T20:18:50+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-city-travel</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>n个节点构成一个树形网络（即n-1条边），从1号节点出发，经过每条边恰两次，给定其中m个节点的遍历顺序，问是否可能满足。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1041">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>仔细思考可以发现，一次遍历即是一次深度优先搜索的过程。对给定的m个节点的遍历顺序，我们可以先对这棵树进行预处理，在每个节点存储以该节点为根的子树所包含节点的集合。用一个队列保存m个节点的遍历顺序，在实际深搜的过程中，每次搜索到一个节点时我们都优先从其包含队首节点的子节点进行搜索。如果深搜结束后队列为空，则返回真；否则返回假。</p>

<h2>时间复杂度</h2>

<p>深度优先搜索的时间复杂度为N，对每个节点而言，其每个子节点都有可能会被重复检查（因为回溯的缘故），最坏情况是N<sup>2</sup>（树仅有两层，且每次队首节点都出现在最右侧）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
using namespace std;

struct Node {
    int id = -1;
    bool visited = false;
    bool tagged = false;
    bitset&lt;101&gt; subtree;
    vector&lt;Node*&gt; successors;

    Node() {
        subtree.reset();
    }
};

class Tree {
private:
    Node* root;

    void collectSubtree(Node* node) {
        node-&gt;tagged = true;
        node-&gt;subtree[node-&gt;id] = 1;
        for (int i = 0; i &lt; node-&gt;successors.size(); i++) {
            if (!node-&gt;successors[i]-&gt;tagged) {
                collectSubtree(node-&gt;successors[i]);
                node-&gt;subtree |= node-&gt;successors[i]-&gt;subtree;
            }
        }
    }

    void traverseTree(Node* node, queue&lt;int&gt;&amp; seq) {
        node-&gt;visited = true;
        if (node-&gt;id == seq.front())
            seq.pop();

        int lastSize = seq.size();
        while (!seq.empty()) {
            for (int i = 0; i &lt; node-&gt;successors.size(); i++)
                if (!node-&gt;successors[i]-&gt;visited &amp;&amp; node-&gt;successors[i]-&gt;subtree[seq.front()]) {
                    traverseTree(node-&gt;successors[i], seq);
                    break;
                }
            if (lastSize == seq.size())
                break;
            lastSize = seq.size();
        }
    }

public:
    Tree(Node* node) {
        root = node;
    }

    bool traverse(queue&lt;int&gt; sequence) {
        queue&lt;int&gt; seq = sequence;
        collectSubtree(root);
        traverseTree(root, seq);
        return seq.empty();
    }
};

int main() {
    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        int n = 0, m = 0;
        cin &gt;&gt; n;
        Node* nodes = new Node[n + 1];
        for (int i = 1; i &lt; n + 1; i++)
            nodes[i].id = i;
        for (int i = 0; i &lt; n - 1; i++) {
            int a = 0, b = 0;
            cin &gt;&gt; a &gt;&gt; b;
            nodes[a].successors.push_back(nodes + b);
            nodes[b].successors.push_back(nodes + a);
        }
        cin &gt;&gt; m;
        queue&lt;int&gt; sequence;
        for (int i = 0; i &lt; m; i++) {
            int a = 0;
            cin &gt;&gt; a;
            sequence.push(a);
        }
        Tree tree = Tree(nodes + 1);

        cout &lt;&lt; (tree.traverse(sequence) ? "YES" : "NO") &lt;&lt; endl;

        delete[] nodes;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1040 - 矩形判断]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-rectangle-check/"/>
    <updated>2016-05-12T20:03:25+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-rectangle-check</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给出平面上4条线段，判断这4条线段是否恰好围成一个面积大于0的矩形。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1040">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>死条线段能够围成矩形的充要条件为：任意两条线段若相交必垂直，且相交次数恰好为4。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为1。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

bool intersect(int* line1, int* line2) {
    return ((line1[0] == line2[0] &amp;&amp; line1[1] == line2[1]) ||
        (line1[0] == line2[2] &amp;&amp; line1[1] == line2[3]) ||
        (line1[2] == line2[0] &amp;&amp; line1[3] == line2[1]) ||
        (line1[2] == line2[2] &amp;&amp; line1[3] == line2[3]));
}

bool isVertical(int* line1, int* line2) {
    int x1 = line1[2] - line1[0];
    int y1 = line1[3] - line1[1];
    int x2 = line2[2] - line2[0];
    int y2 = line2[3] - line2[1];

    return (x1 * x2 + y1 * y2) == 0;
}

bool isPoint(int* line) {
    return (line[0] == line[2] &amp;&amp; line[1] == line[3]);
}

bool checkRec(int** coord) {
    for (int i = 0; i &lt; 4; i++)
        if (isPoint(coord[i]))
            return false;

    int count = 0;
    for (int i = 0; i &lt; 4; i++) {
        for (int j = i + 1; j &lt; 4; j++) {
            if (intersect(coord[i], coord[j])) {
                if (isVertical(coord[i], coord[j]))
                    count++;
                else
                    return false;
            }
        }
    }
    if (count == 4)
        return true;

    return false;
}

int main() {
    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        int** coord = new int*[4];
        for (int i = 0; i &lt; 4; i++)
            coord[i] = new int[4];
        for (int i = 0; i &lt; 4; i++)
            for (int j = 0; j &lt; 4; j++)
                cin &gt;&gt; coord[i][j];

        cout &lt;&lt; (checkRec(coord) ? "YES" : "NO") &lt;&lt; endl;

        for (int i = 0; i &lt; 4; i++)
            delete[] coord[i];
        delete[] coord;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1038 - 01背包]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-01-package/"/>
    <updated>2016-05-12T17:57:15+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-01-package</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>经典01背包问题。给定有限空间M，N件物品，每件物品对应体积C及价值V，求最大能获得的价值总和。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1038">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>动态规划。递推式为：<br/>
<code>f[i, j] = max(f[i-1, j-C[i]] + V[i], f[i-1, j])</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为MN，空间复杂度为2M，进一步可优化为M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxValue(int* needs, int* values, int N, int M) {
    int** V = new int*[2];
    for (int i = 0; i &lt; 2; i++)
        V[i] = new int[M + 1];

    for (int i = 0; i &lt; M + 1; i++)
        V[0][i] = 0;
    int curLine = 1;
    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; M + 1; j++) {
            if (needs[i] &lt;= j)
                V[curLine][j] = max(V[1 - curLine][j - needs[i]] + values[i], V[1 - curLine][j]);
            else
                V[curLine][j] = V[1 - curLine][j];
        }
        curLine = 1 - curLine;
    }

    int maxV = V[1 - curLine][M];

    for (int i = 0; i &lt; 2; i++)
        delete[] V[i];
    delete[] V;

    return maxV;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    int *needs = new int[N], *values = new int[N];
    for (int i = 0; i &lt; N; i++)
        cin &gt;&gt; needs[i] &gt;&gt; values[i];

    cout &lt;&lt; maxValue(needs, values, N, M) &lt;&lt; endl;

    delete[] needs, values;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1037 - 数字三角形]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-number-triangle/"/>
    <updated>2016-05-12T17:32:59+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-number-triangle</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>一个三角形的n层迷宫，第i层有i个格子，每个格子里有一些礼品，第i层编号为j的格子可以通向第i+1层编号为j、j+1的格子。通道是单向的。求问从第1层第一个格子开始，一直走到迷宫最高层，最多能获得多少礼品。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1037">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>很简单的动态规划。递推式：<br/>
<code>f[i+1, j] = max(f[i, j-1], f[i, j]) + V[i+1, j]</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为N<sup>2</sup>，空间复杂度为1（因为输入数据的矩阵维度与需要计算的一致）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxA(int** A, int n) {
    for (int i = 1; i &lt; n; i++) {
        A[i][0] = A[i - 1][0] + A[i][0];
        for (int j = 1; j &lt;= i; j++)
            A[i][j] = max(A[i - 1][j - 1], A[i - 1][j]) + A[i][j];
    }

    int maxV = 0;
    for (int i = 0; i &lt; n; i++)
        maxV = max(maxV, A[n - 1][i]);

    return maxV;
}

int main() {
    int n = 0;
    cin &gt;&gt; n;
    int** A = new int*[n];
    for (int i = 0; i &lt; n; i++)
        A[i] = new int[n];
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt;= i; j++)
            cin &gt;&gt; A[i][j];

    cout &lt;&lt; maxA(A, n) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
