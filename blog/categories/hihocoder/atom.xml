<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hihocoder | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/hihocoder/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-15T16:35:48+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1067 - 最近公共祖先·二]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/15/hihocoder-lowest-common-ancestor-2/"/>
    <updated>2016-05-15T15:02:25+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/15/hihocoder-lowest-common-ancestor-2</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定N对节点之间的继承关系（一个节点仅有一个父节点），并且所有这些节点有一个共同的根节点，给定任意两个节点，求它们的最近公共祖先节点。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1067">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>这次用到的算法称为离线算法，因为要求一次收集若干次询问统一处理。仔细思考，可以发现：<br/>
对树进行深度优先搜索，并且对节点进行染色（进去时染灰色，离开时染黑色），当遍历到某个询问的节点时，查看另一个节点，若未染色，则继续；若是灰色，则结果就是该灰色节点；若是黑色，则结果就是该黑色节点向上的第一个灰色节点（黑色节点表示其子树已经全部访问完，灰色节点表示当前仍在其子树中）。<br/>
接下来的问题是如何快速查找一个黑色节点向上的第一个灰色节点。仔细思考，发现当刚要离开一个节点时，其所有子树中的节点向上的第一个灰色节点即为其自身，那么当该节点染黑后，以该节点为根节点的子树中所有节点向上的第一个灰色节点就变成了该节点的父节点。这很类似于并查集。</p>

<h2>时间复杂度</h2>

<p>DFS的时间复杂度是N，共M次询问，其中并查集的合并及查找共2M + N次，时间复杂度为2N + 2M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

struct Node {
    string name;
    vector&lt;Node*&gt; successors;
    int visited = 0;
    string ancestor;

    Node(string n) :name(n) {}
};

struct Query {
    string to;
    string ans;

    Query() :ans("") {}
};

unordered_map&lt;string, Node*&gt; tree;
Query* Q1;
Query* Q2;
unordered_map&lt;string, vector&lt;Query*&gt;&gt; queries;

string find(Node* node) {
    if (node-&gt;ancestor == node-&gt;name)
        return node-&gt;name;
    node-&gt;ancestor = find(tree[node-&gt;ancestor]);
    return node-&gt;ancestor;
}

void dfs(Node* root) {
    root-&gt;visited = 1;
    root-&gt;ancestor = root-&gt;name;
    if (queries.find(root-&gt;name) != queries.end()) {
        for (int i = 0; i &lt; queries[root-&gt;name].size(); i++) {
            if (tree[queries[root-&gt;name][i]-&gt;to]-&gt;visited &gt; 0)
                queries[root-&gt;name][i]-&gt;ans = find(tree[queries[root-&gt;name][i]-&gt;to]);
        }
    }
    for (int i = 0; i &lt; root-&gt;successors.size(); i++) {
        dfs(root-&gt;successors[i]);
        root-&gt;successors[i]-&gt;ancestor = root-&gt;name;
    }
    root-&gt;visited = 2;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N;
    string father, son;
    cin &gt;&gt; father &gt;&gt; son;
    tree[father] = new Node(father);
    Node* root = tree[father];
    tree[son] = new Node(son);
    tree[father]-&gt;successors.push_back(tree[son]);
    for (int i = 1; i &lt; N; i++) {
        string father, son;
        cin &gt;&gt; father &gt;&gt; son;
        if (tree.find(father) == tree.end())
            tree[father] = new Node(father);
        tree[son] = new Node(son);
        tree[father]-&gt;successors.push_back(tree[son]);
    }
    cin &gt;&gt; M;
    Q1 = new Query[M];
    Q2 = new Query[M];
    for (int i = 0; i &lt; M; i++) {
        string left, right;
        cin &gt;&gt; left &gt;&gt; right;
        Q1[i].to = right;
        Q2[i].to = left;
        queries[left].push_back(Q1 + i);
        queries[right].push_back(Q2 + i);
    }

    dfs(root);

    for (int i = 0; i &lt; M; i++) {
        if (Q1[i].ans != "")
            cout &lt;&lt; Q1[i].ans &lt;&lt; endl;
        else
            cout &lt;&lt; Q2[i].ans &lt;&lt; endl;
    }

    for (auto it = tree.begin(); it != tree.end(); it++)
        delete it-&gt;second;
    delete[] Q1, Q2;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1066 - 无间道之并查集]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/15/hihocoder-union-set/"/>
    <updated>2016-05-15T14:42:06+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/15/hihocoder-union-set</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个n个不同元素的集合，这些元素被分成不相交集合，且最开始每个元素自成一个集合。现在考虑两种运算：find(x)和union(x, y)，find(x)返回包含x的集合名字，union(x, y)则将包含x和y的两个集合合并。设计一种数据结构满足高效率的上述两种运算。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1066">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典的Union-Find Set问题。首先很容易想到树形结构，每个集合对应一棵树，所有集合就是一片森林。find操作就是查找根节点，union操作就是合并两棵树。关键在于路径压缩，即每次执行find和union操作时我们应尽可能使树的高度降低，这样下次执行find和union操作时查找根节点的时间就大大减少了。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为Mlog<sup><em></sup>N。在实际应用中由于log<sup></em></sup>N &lt;= 5，时间复杂度即M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

unordered_map&lt;string, string&gt; unionFindSet;

string find(string n) {
    if (unionFindSet[n] == n)
        return n;
    unionFindSet[n] = find(unionFindSet[n]);
    return unionFindSet[n];
}

void unionset(string a, string b) {
    if (unionFindSet.find(a) == unionFindSet.end())
        unionFindSet[a] = a;
    if (unionFindSet.find(b) == unionFindSet.end())
        unionFindSet[b] = b;
    unionFindSet[find(unionFindSet[a])] = find(unionFindSet[b]);
}

bool company(string a, string b) {
    if (unionFindSet.find(a) == unionFindSet.end() || unionFindSet.find(b) == unionFindSet.end())
        return false;
    return find(unionFindSet[a]) == find(unionFindSet[b]);
}

int main() {
    int N = 0;
    cin &gt;&gt; N;
    for (int i = 0; i &lt; N; i++) {
        int op = 0;
        string a, b;
        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
        if (op)
            cout &lt;&lt; (company(a, b) ? "yes" : "no") &lt;&lt; endl;
        else
            unionset(a, b);
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihocCoder#1062 - 最近公共祖先·一]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/15/hihocoder-lowest-common-ancestor/"/>
    <updated>2016-05-15T14:24:56+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/15/hihocoder-lowest-common-ancestor</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定N对节点之间的继承关系（一个节点仅有一个父节点），给定任意两个节点，求它们的最近公共祖先节点。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1062">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>采用链表存储节点信息，由于存储的是子节点->父节点的关系，因此可以先遍历其中一个节点的所有祖先节点并标记，再遍历另一个节点的所有祖先节点，当遍历到一个已被标记的祖先节点时，该节点即所求结果。也可以将两个节点遍历到根节点的路径反转然后进行比较，找到开始分叉的那个节点即所求结果。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为T（T为树的高度），最坏情况是N。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

struct Node {
    string name;
    bool visited = false;
    Node* ancestor = NULL;

    Node(string n) {
        name = n;
    }
};

string lowestComAnc(unordered_map&lt;string, Node*&gt; nodes, string a, string b) {
    if (a == b)
        return a;
    if (nodes.find(a) == nodes.end() || nodes.find(b) == nodes.end())
        return "-1";

    for (auto it = nodes.begin(); it != nodes.end(); it++)
        it-&gt;second-&gt;visited = false;

    Node *A = nodes[a], *B = nodes[b];
    while (A) {
        A-&gt;visited = true;
        A = A-&gt;ancestor;
    }

    while (B) {
        if (B-&gt;visited)
            return B-&gt;name;
        B = B-&gt;ancestor;
    }

    return "-1";
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N;
    unordered_map&lt;string, Node*&gt; nodes;
    for (int i = 0; i &lt; N; i++) {
        string father, son;
        cin &gt;&gt; father &gt;&gt; son;
        Node* node = new Node(son);
        if (nodes.find(father) == nodes.end())
            nodes.insert(make_pair(father, new Node(father)));
        node-&gt;ancestor = nodes[father];
        nodes.insert(make_pair(son, node));
    }
    cin &gt;&gt; M;
    for (int i = 0; i &lt; M; i++) {
        string a, b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; lowestComAnc(nodes, a, b) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1061 - Beautiful String]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/15/hihocoder-beautiful-string/"/>
    <updated>2016-05-15T14:16:20+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/15/hihocoder-beautiful-string</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>如果一个字符串包含数量相等的连续的3个或更多字符（递增序），则其是一个beautiful string（如aabbcc）。给定一个字符串，判断是否包含一个beautiful string。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1061">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>简单的搜索即可。</p>

<h2>时间复杂度</h2>

<p>最坏情况下是N<sup>2</sup>。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

bool check(string str, int n) {
    for (int i = 0; i &lt; n; i++) {
        char cache[3] = { str[i], ' ', ' ' };
        int len[3] = { 1, 0, 0 };
        int k = 0;
        for (int j = i + 1; j &lt; n; j++) {
            if (cache[k] == str[j])
                len[k]++;
            else if (cache[k] + 1 == str[j]) {
                if (k == 2)
                    break;
                k++;
                cache[k] = str[j];
                len[k]++;
            }
            else
                break;
            if (len[0] &lt; len[1] || len[1] &lt; len[2])
                break;
            if (k == 2 &amp;&amp; len[0] &gt; len[1])
                break;
            if (k == 2 &amp;&amp; len[1] == len[2])
                return true;
        }
    }

    return false;
}

int main() {
    int t = 0;
    cin &gt;&gt; t;
    for (int i = 0; i &lt; t; i++) {
        int n = 0;
        string str;
        cin &gt;&gt; n &gt;&gt; str;

        cout &lt;&lt; (check(str, n) ? "YES" : "NO") &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1055 - 刷油漆]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/13/hihocoder-painting/"/>
    <updated>2016-05-13T16:49:39+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/13/hihocoder-painting</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一颗树，其中每个节点都有一个价值V，现将其中包含1号节点的M个连通的节点选出来，问可能的最大价值总和。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1055">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>关键在于将问题转化为动态规划。在考虑以t节点为根，选取m个节点的情况时:<br/>
<code>f[t, m] = max(f[c, m1], f[c+1, m2], ..., f[c+k-1, mk] + v[t]), 其中c, c+1, ..., c+k-1为t节点的子节点，且sum(m1, m2, ..., mk) = m-1</code><br/>
此时将c, c+1, &hellip;, c+k-1考虑成排好序的k件物品，背包容量为m-1，那么这就类似于背包问题。用F[c, m]表示从前c个子树里选取了m个节点能取得的最大值，则有如下递推式：<br/>
<code>F[c, m] = max(F[c-1, m-i] + f[c, i]) 其中0&lt;=i&lt;=m</code><br/>
且<code>f[t, m] = F[c+k-1, m-1] + V[t]</code>。注意该递推式可优化为：<br/>
<code>f[t, m] = max(f[t, m-j-1] + f[c+i, j]) + V[t] 其中0&lt;=i&lt;k，0&lt;j&lt;=m-1</code>。<br/>
这里用到了空间压缩的思想，注意迭代顺序。然后采用后序遍历，自底向上计算所有f[t, m]，最终结果就是f[1, M]的值。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为M<sup>2</sup>N。空间复杂度为MN。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Node {
    int id = -1;
    int score = 0;
    bool visited = false;
    vector&lt;Node*&gt; successors;
};

class Tree {
private:
    Node* root;
    int** F;
    int N, M;

    void traverseTree(Node* node) {
        node-&gt;visited = true;
        for (int i = 0; i &lt; node-&gt;successors.size(); i++)
            if (!node-&gt;successors[i]-&gt;visited)
                traverseTree(node-&gt;successors[i]);

        F[node-&gt;id][1] = node-&gt;score;
        for (int i = 0; i &lt; node-&gt;successors.size(); i++) {
            if (!node-&gt;successors[i]-&gt;visited) {
                for (int j = M; j &gt;= 2; j--) {
                    for (int k = 1; k &lt; j; k++)
                        F[node-&gt;id][j] = max(F[node-&gt;id][j], F[node-&gt;id][j - k] + F[node-&gt;successors[i]-&gt;id][k]);
                }
            }
        }

        node-&gt;visited = false;
    }

public:
    Tree(Node* node, int n, int m) {
        N = n;
        M = m;
        root = node;
        F = new int*[N + 1];
        for (int i = 0; i &lt; N + 1; i++) {
            F[i] = new int[M + 1];
            for (int j = 0; j &lt; M + 1; j++)
                F[i][j] = 0;
        }
    }

    ~Tree() {
        for (int i = 0; i &lt; N; i++)
            delete[] F[i];
        delete[] F;
    }

    int maxScore() {
        traverseTree(root);
        return F[1][M];
    }
};

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    Node* nodes = new Node[N + 1];
    for (int i = 1; i &lt; N + 1; i++) {
        int s = 0;
        cin &gt;&gt; s;
        nodes[i].id = i;
        nodes[i].score = s;
    }
    for (int i = 0; i &lt; N - 1; i++) {
        int a = 0, b = 0;
        cin &gt;&gt; a &gt;&gt; b;
        nodes[a].successors.push_back(nodes + b);
        nodes[b].successors.push_back(nodes + a);
    }
    Tree tree = Tree(nodes + 1, N, M);

    cout &lt;&lt; tree.maxScore() &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
