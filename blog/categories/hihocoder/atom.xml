<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hihocoder | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/hihocoder/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-12T20:58:46+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1041 - 国庆出游]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-city-travel/"/>
    <updated>2016-05-12T20:18:50+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-city-travel</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>n个节点构成一个树形网络（即n-1条边），从1号节点出发，经过每条边恰两次，给定其中m个节点的遍历顺序，问是否可能满足。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1041">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>仔细思考可以发现，一次遍历即是一次深度优先搜索的过程。对给定的m个节点的遍历顺序，我们可以先对这棵树进行预处理，在每个节点存储以该节点为根的子树所包含节点的集合。用一个队列保存m个节点的遍历顺序，在实际深搜的过程中，每次搜索到一个节点时我们都优先从其包含队首节点的子节点进行搜索。如果深搜结束后队列为空，则返回真；否则返回假。</p>

<h2>时间复杂度</h2>

<p>深度优先搜索的时间复杂度为N，对每个节点而言，其每个子节点都有可能会被重复检查（因为回溯的缘故），最坏情况是N<sup>2</sup>（树仅有两层，且每次队首节点都出现在最右侧）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
using namespace std;

struct Node {
    int id = -1;
    bool visited = false;
    bool tagged = false;
    bitset&lt;101&gt; subtree;
    vector&lt;Node*&gt; successors;

    Node() {
        subtree.reset();
    }
};

class Tree {
private:
    Node* root;

    void collectSubtree(Node* node) {
        node-&gt;tagged = true;
        node-&gt;subtree[node-&gt;id] = 1;
        for (int i = 0; i &lt; node-&gt;successors.size(); i++) {
            if (!node-&gt;successors[i]-&gt;tagged) {
                collectSubtree(node-&gt;successors[i]);
                node-&gt;subtree |= node-&gt;successors[i]-&gt;subtree;
            }
        }
    }

    void traverseTree(Node* node, queue&lt;int&gt;&amp; seq) {
        node-&gt;visited = true;
        if (node-&gt;id == seq.front())
            seq.pop();

        int lastSize = seq.size();
        while (!seq.empty()) {
            for (int i = 0; i &lt; node-&gt;successors.size(); i++)
                if (!node-&gt;successors[i]-&gt;visited &amp;&amp; node-&gt;successors[i]-&gt;subtree[seq.front()]) {
                    traverseTree(node-&gt;successors[i], seq);
                    break;
                }
            if (lastSize == seq.size())
                break;
            lastSize = seq.size();
        }
    }

public:
    Tree(Node* node) {
        root = node;
    }

    bool traverse(queue&lt;int&gt; sequence) {
        queue&lt;int&gt; seq = sequence;
        collectSubtree(root);
        traverseTree(root, seq);
        return seq.empty();
    }
};

int main() {
    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        int n = 0, m = 0;
        cin &gt;&gt; n;
        Node* nodes = new Node[n + 1];
        for (int i = 1; i &lt; n + 1; i++)
            nodes[i].id = i;
        for (int i = 0; i &lt; n - 1; i++) {
            int a = 0, b = 0;
            cin &gt;&gt; a &gt;&gt; b;
            nodes[a].successors.push_back(nodes + b);
            nodes[b].successors.push_back(nodes + a);
        }
        cin &gt;&gt; m;
        queue&lt;int&gt; sequence;
        for (int i = 0; i &lt; m; i++) {
            int a = 0;
            cin &gt;&gt; a;
            sequence.push(a);
        }
        Tree tree = Tree(nodes + 1);

        cout &lt;&lt; (tree.traverse(sequence) ? "YES" : "NO") &lt;&lt; endl;

        delete[] nodes;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1040 - 矩形判断]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-rectangle-check/"/>
    <updated>2016-05-12T20:03:25+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-rectangle-check</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给出平面上4条线段，判断这4条线段是否恰好围成一个面积大于0的矩形。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1040">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>死条线段能够围成矩形的充要条件为：任意两条线段若相交必垂直，且相交次数恰好为4。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为1。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

bool intersect(int* line1, int* line2) {
    return ((line1[0] == line2[0] &amp;&amp; line1[1] == line2[1]) ||
        (line1[0] == line2[2] &amp;&amp; line1[1] == line2[3]) ||
        (line1[2] == line2[0] &amp;&amp; line1[3] == line2[1]) ||
        (line1[2] == line2[2] &amp;&amp; line1[3] == line2[3]));
}

bool isVertical(int* line1, int* line2) {
    int x1 = line1[2] - line1[0];
    int y1 = line1[3] - line1[1];
    int x2 = line2[2] - line2[0];
    int y2 = line2[3] - line2[1];

    return (x1 * x2 + y1 * y2) == 0;
}

bool isPoint(int* line) {
    return (line[0] == line[2] &amp;&amp; line[1] == line[3]);
}

bool checkRec(int** coord) {
    for (int i = 0; i &lt; 4; i++)
        if (isPoint(coord[i]))
            return false;

    int count = 0;
    for (int i = 0; i &lt; 4; i++) {
        for (int j = i + 1; j &lt; 4; j++) {
            if (intersect(coord[i], coord[j])) {
                if (isVertical(coord[i], coord[j]))
                    count++;
                else
                    return false;
            }
        }
    }
    if (count == 4)
        return true;

    return false;
}

int main() {
    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        int** coord = new int*[4];
        for (int i = 0; i &lt; 4; i++)
            coord[i] = new int[4];
        for (int i = 0; i &lt; 4; i++)
            for (int j = 0; j &lt; 4; j++)
                cin &gt;&gt; coord[i][j];

        cout &lt;&lt; (checkRec(coord) ? "YES" : "NO") &lt;&lt; endl;

        for (int i = 0; i &lt; 4; i++)
            delete[] coord[i];
        delete[] coord;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1038 - 01背包]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-01-package/"/>
    <updated>2016-05-12T17:57:15+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-01-package</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>经典01背包问题。给定有限空间M，N件物品，每件物品对应体积C及价值V，求最大能获得的价值总和。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1038">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>动态规划。递推式为：<br/>
<code>f[i, j] = max(f[i-1, j-C[i]] + V[i], f[i-1, j])</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为MN，空间复杂度为2M，进一步可优化为M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxValue(int* needs, int* values, int N, int M) {
    int** V = new int*[2];
    for (int i = 0; i &lt; 2; i++)
        V[i] = new int[M + 1];

    for (int i = 0; i &lt; M + 1; i++)
        V[0][i] = 0;
    int curLine = 1;
    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; M + 1; j++) {
            if (needs[i] &lt;= j)
                V[curLine][j] = max(V[1 - curLine][j - needs[i]] + values[i], V[1 - curLine][j]);
            else
                V[curLine][j] = V[1 - curLine][j];
        }
        curLine = 1 - curLine;
    }

    int maxV = V[1 - curLine][M];

    for (int i = 0; i &lt; 2; i++)
        delete[] V[i];
    delete[] V;

    return maxV;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    int *needs = new int[N], *values = new int[N];
    for (int i = 0; i &lt; N; i++)
        cin &gt;&gt; needs[i] &gt;&gt; values[i];

    cout &lt;&lt; maxValue(needs, values, N, M) &lt;&lt; endl;

    delete[] needs, values;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1037 - 数字三角形]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-number-triangle/"/>
    <updated>2016-05-12T17:32:59+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-number-triangle</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>一个三角形的n层迷宫，第i层有i个格子，每个格子里有一些礼品，第i层编号为j的格子可以通向第i+1层编号为j、j+1的格子。通道是单向的。求问从第1层第一个格子开始，一直走到迷宫最高层，最多能获得多少礼品。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1037">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>很简单的动态规划。递推式：<br/>
<code>f[i+1, j] = max(f[i, j-1], f[i, j]) + V[i+1, j]</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为N<sup>2</sup>，空间复杂度为1（因为输入数据的矩阵维度与需要计算的一致）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxA(int** A, int n) {
    for (int i = 1; i &lt; n; i++) {
        A[i][0] = A[i - 1][0] + A[i][0];
        for (int j = 1; j &lt;= i; j++)
            A[i][j] = max(A[i - 1][j - 1], A[i - 1][j]) + A[i][j];
    }

    int maxV = 0;
    for (int i = 0; i &lt; n; i++)
        maxV = max(maxV, A[n - 1][i]);

    return maxV;
}

int main() {
    int n = 0;
    cin &gt;&gt; n;
    int** A = new int*[n];
    for (int i = 0; i &lt; n; i++)
        A[i] = new int[n];
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt;= i; j++)
            cin &gt;&gt; A[i][j];

    cout &lt;&lt; maxA(A, n) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1032 - 最长回文子串]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-longest-palindromic-substring/"/>
    <updated>2016-05-12T16:04:46+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>回文串定义为从左往右及从右往左是完全一样的字符串。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1032">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>直接暴力搜索复杂度为N<sup>2</sup>。因为是求子串而非子序列，所以动态规划的思路也不可行。考虑对搜索过程进行优化：<br/>
首先仅考虑长度为奇数的子串，那么以字符串中任意一个字符为中心搜索其最长的回文子串（利用对称）。<br/>
其次考虑可利用的现有信息。如下：<br/>
<code>caabaacd</code><br/>
假设目前已知f[4] = 7，f[5] = 1，求f[6]，我们可以发现，由于f[4] = 7，字符串[5, 7]和[3, 1]是完全相等的，即如果[1, 3]是回文子串，那么[5, 7]也是回文子串。这也就意味着如果f[2] &lt; 3，那么f[6] = f[2]；如果f[2] >= 3，那么f[6] >= 3（注意2是6以4为中心的对称坐标）。假设每次在求第i个位置为中心的最长回文子串时，我们已知能达到最右端点P的是以第j个位置为中心的最长回文子串，其右端点为j + f[j]/2，这样我们可以得到一个下述关系：<br/>
<code>f[i] &gt;= min(f[2j-i], f[2j-2i+f[j])</code><br/>
这样每次搜索时可以省去很多冗余搜索。<br/>
最后一个问题是怎么将上述方法推广到求偶数长度的回文子串。只需要在原字符串的基础上每两个相邻字符间插入一个特殊字符，那么原字符串的最长回文子串一定对应着新串的一个奇数最长回文子串。</p>

<h2>时间复杂度</h2>

<p>每一步里如果f[2j-i] &lt; 2j-2i+f[j]那么f[i] = f[2j-i]，否则我们以i为中心进行扩展，此时要么最大右边界P不移动；要么最大右边界P会往右移动，最多N次。总共2N次操作。时间复杂度为2N。（参考<a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii/">Longest Palindromic Substring Part II</a>）</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

int longestPalSubStr(string str) {
    string modStr = "";
    modStr += str[0];
    for (int i = 1; i &lt; str.size(); i++) {
        modStr += '$';
        modStr += str[i];
    }

    int maxL = 0;
    int* f = new int[modStr.size()];
    for (int i = 0; i &lt; modStr.size(); i++)
        f[i] = 1;
    int maxBorder = 0;
    for (int i = 0; i &lt; modStr.size(); i++) {
        int minL = min(f[2 * maxBorder - i], f[maxBorder] - 2 * (i - maxBorder));
        f[i] = minL &gt; 0 ? minL : 0;
        for (int j = (minL - 1) / 2 + 1; i - j &gt;= 0 &amp;&amp; i + j &lt; modStr.size(); j++) {
            if (modStr[i + j] != modStr[i - j])
                break;
            f[i] += 2;
        }
        maxBorder = f[i] / 2 + i &gt; f[maxBorder] / 2 + maxBorder ? i : maxBorder;
        maxL = max(maxL, i % 2 == 1 ? (f[i] + 1) / 4 * 2 : (f[i] - 1) / 4 * 2 + 1 );
    }

    return maxL;
} 

int main() {
    int N = 0; 
    cin &gt;&gt; N;
    for (int i = 0; i &lt; N; i++) {
        string str;
        cin &gt;&gt; str;

        cout &lt;&lt; longestPalSubStr(str) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
