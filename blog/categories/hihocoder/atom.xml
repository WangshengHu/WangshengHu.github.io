<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hihocoder | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/hihocoder/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-16T21:18:14+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1098 - Kruskal算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-kruscal/"/>
    <updated>2016-05-16T20:24:40+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-kruscal</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，求最小生成树。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1098">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典的Kruskal算法。<br/>
1. 对图中的边以非降序排列；<br/>
2. 对排好序的每条边，如果加入最小生成树不会形成环（采用<a href="/blog/2016/05/15/hihocoder-union-set/">Union-Find Set</a>实现），则加入最小生成树。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为MlogM。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Edge {
    int a = 0;
    int b = 0;
    int length = 0;
};

class FindUnionSet {
private:
    int N;
    int* nodes;

public:
    FindUnionSet(int N) {
        nodes = new int[N + 1];
        for (int i = 1; i &lt;= N; i++)
            nodes[i] = i;
    }

    ~FindUnionSet() {
        delete[] nodes;
    }

    int find(int node) {
        if (nodes[node] == node)
            return node;
        nodes[node] = find(nodes[node]);
        return nodes[node];
    }

    void unionset(int a, int b) {
        nodes[find(nodes[a])] = find(nodes[b]);
    }
};

bool edgesCmp(const Edge&amp; a, const Edge&amp; b) {
    return a.length &lt; b.length;
}

int kruskal(vector&lt;Edge&gt; edges, int N, int M) {
    sort(edges.begin(), edges.end(), edgesCmp);
    FindUnionSet set = FindUnionSet(N);
    int minCost = 0;
    int i = 0;
    int k = 0;
    while (i &lt; N - 1) {
        if (set.find(edges[k].a) != set.find(edges[k].b)) {
            set.unionset(edges[k].a, edges[k].b);
            minCost += edges[k].length;
            i++;
        }
        k++;
    }

    return minCost;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    vector&lt;Edge&gt; edges = vector&lt;Edge&gt;(M);
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        edges[i].a = a;
        edges[i].b = b;
        edges[i].length = edge;
    }

    cout &lt;&lt; kruskal(edges, N, M) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1097 - Prim算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-prim/"/>
    <updated>2016-05-16T19:46:33+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-prim</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，求最小生成树。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1097">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典的Prim算法。<br/>
1. 初始化集合X和Y，X = {1}, Y = V - {1}；<br/>
2. 查找最短的一条边(x, y)，其中x属于X，y属于Y，并将其加入最小生成树。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为N<sup>2</sup>。采用堆实现的话可以减小到MlogN。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
using namespace std;

int prim(int** graph, int N) {
    bitset&lt;1000&gt; set;
    set.reset();
    int* d = new int[N];
    for (int i = 0; i &lt; N; i++)
        d[i] = graph[0][i];
    set[0] = 1;
    int minCost = 0;
    for (int i = 1; i &lt; N; i++) {
        int minNode = 0;
        int minEdge = -1;
        for (int j = 0; j &lt; N; j++) {
            if (set[j])
                continue;
            if (minEdge == -1 || (d[j] !=-1 &amp;&amp; minEdge &gt; d[j])) {
                minEdge = d[j];
                minNode = j;
            }
        }
        minCost += minEdge;
        set[minNode] = 1;
        for (int j = 0; j &lt; N; j++) {
            if (set[j])
                continue;
            if (d[j] == -1 || d[j] &gt; graph[minNode][j]) {
                d[j] = graph[minNode][j];
            }
        }
    }

    return minCost;
}

int main() {
    int N = 0;
    cin &gt;&gt; N;
    int** graph = new int*[N];
    for (int i = 0; i &lt; N; i++) {
        graph[i] = new int[N];
        for (int j = 0; j &lt; N; j++) {
            int edge = 0;
            cin &gt;&gt; edge;
            graph[i][j] = edge;
        }
    }

    cout &lt;&lt; prim(graph, N) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1093 - SPFA算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-spfa/"/>
    <updated>2016-05-16T19:12:45+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-spfa</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，两个顶点之间可能有多条边，求顶点1到顶点N的最短路径。给定的图中边的数量较少。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1093">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>SPFA算法，即Shortest Path Faster Algorithm。对图进行广度优先搜索，并且在搜索的过程中实时更新所有顶点到顶点1的最短距离。具体来说，是在一个顶点出队时查看它的所有邻接顶点，并更新它们的最短距离，如果它们不在队列中则入队。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为O(kE)，k是个比较小的系数（并且在绝大多数的图中，k&lt;=2，然而在一些精心构造的图中可能会上升到很高）（摘自<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95">维基百科</a>）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct Node {
    int d = -1;
    bool inQueue = false;
    vector&lt;Node*&gt; neighbors;
    vector&lt;int&gt; edges;
};

int spfa(Node* graph, int s, int t) {
    Node* S = graph + s;
    S-&gt;d = 0;
    queue&lt;Node*&gt; queue;
    queue.push(S);
    while (!queue.empty()) {
        Node* cur = queue.front();
        cur-&gt;inQueue = false;
        queue.pop();
        for (int i = 0; i &lt; cur-&gt;neighbors.size(); i++) {
            if (cur-&gt;neighbors[i]-&gt;d == -1 || cur-&gt;neighbors[i]-&gt;d &gt; cur-&gt;d + cur-&gt;edges[i]) {
                cur-&gt;neighbors[i]-&gt;d = cur-&gt;d + cur-&gt;edges[i];
                if (!cur-&gt;neighbors[i]-&gt;inQueue) {
                    cur-&gt;neighbors[i]-&gt;inQueue = true;
                    queue.push(cur-&gt;neighbors[i]);
                }
            }
        }
    }

    return graph[t].d;
}

int main() {
    int N = 0, M = 0, S = 0, T = 0;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T;
    Node* graph = new Node[N + 1];
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        graph[a].neighbors.push_back(graph + b);
        graph[a].edges.push_back(edge);
        graph[b].neighbors.push_back(graph + a);
        graph[b].edges.push_back(edge);
    }

    cout &lt;&lt; spfa(graph, S, T) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1089 - Floyd算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-floyd/"/>
    <updated>2016-05-16T18:55:10+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-floyd</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，两个顶点之间可能有多条边，求任意两个顶点之间的最短路径。  <br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1089">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典的Floyd算法。采用动态规划的思想，假设d[i, j]是从i到j的距离，且路径允许经过的节点数慢慢增加。写成递推式就是<br/>
<code>d[i, j] = min(d[i, j], d[i, k] + d[k, j])</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为N<sup>3</sup>，空间复杂度为N<sup>2</sup>。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

void floyd(int** graph, int N) {
    for (int k = 1; k &lt;= N; k++) {
        for (int i = 1; i &lt;= N; i++)
            for (int j = 1; j &lt;= N; j++) {
                if (graph[i][k] != -1 &amp;&amp; graph[k][j] != -1) {
                    if (graph[i][j] == -1)
                        graph[i][j] = graph[i][k] + graph[k][j];
                    else
                        graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
                }
            }
    }
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    int** graph = new int*[N + 1];
    for (int i = 1; i &lt; N + 1; i++) {
        graph[i] = new int[N + 1];
        for (int j = 1; j &lt; N + 1; j++)
            graph[i][j] = -1;
        graph[i][i] = 0;
    }
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        if (graph[a][b] == -1) {
            graph[a][b] = edge;
            graph[b][a] = edge;
        }
        else if (graph[a][b] &gt; edge) {
            graph[a][b] = edge;
            graph[b][a] = edge;
        }
    }

    floyd(graph, N);
    for (int i = 1; i &lt;= N; i++) {
        for (int j = 1; j &lt;= N; j++)
            cout &lt;&lt; graph[i][j] &lt;&lt; " ";
        cout &lt;&lt; endl;
    }

    for (int i = 1; i &lt; N + 1; i++)
        delete[] graph[i];
    delete[] graph;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1081 - 最短路径·一]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-dijkstra/"/>
    <updated>2016-05-16T17:21:52+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-dijkstra</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，两个顶点之间可能有多条边，求顶点1到顶点N的最短路径。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1081">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典Dijkstra算法。<br/>
1. 初始化集合X和Y，X = {1}, Y = V - {1}；<br/>
2. 对顶点1的所有相邻顶点，更新d[i] = 边长；否则d[i] = 无穷大；<br/>
3. 从Y中选取一个d最小的顶点v，将v从Y中删除并加入X，更新所有与v相邻顶点的d。<br/>
注意我在实现时采用了C++ STL的priority_queue结构。由于priority_queue不提供随机访问的功能（即获取其中一个元素的具体位置）这样会导致第3步中每次更新时都要进行一次入队操作。</p>

<h2>时间复杂度</h2>

<p>朴素的实现是N<sup>2</sup>，如果采用堆实现的话可以减小到MlogN。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
using namespace std;

struct Node {
    int id = -1;
    int d = -1;
    vector&lt;int&gt; neighbors;
    vector&lt;int&gt; edges;
};

struct NodeCmp {
    bool operator()(const Node &amp;a, const Node &amp;b) const {
        return b.d &lt; a.d;
    }
};

int dijkstra(Node* graph, int N, int s, int t) {
    bitset&lt;1001&gt; set;
    set.reset();
    priority_queue&lt;Node, vector&lt;Node&gt;, NodeCmp&gt; heap;
    graph[s].d = 0;
    set[s] = 1;
    for (int i = 0; i &lt; graph[s].neighbors.size(); i++) {
        graph[graph[s].neighbors[i]].d = graph[s].edges[i];
        heap.push(graph[graph[s].neighbors[i]]);
    }

    int i = 0;
    while (i &lt; N - 1) {
        Node nearestNode = heap.top();
        heap.pop();
        if (set[nearestNode.id])
            continue;
        i++;
        set[nearestNode.id] = 1;
        for (int j = 0; j &lt; nearestNode.neighbors.size(); j++) {
            if (graph[nearestNode.neighbors[j]].d == -1 || nearestNode.edges[j] + nearestNode.d &lt; graph[nearestNode.neighbors[j]].d)
                graph[nearestNode.neighbors[j]].d = nearestNode.edges[j] + nearestNode.d;
            heap.push(graph[nearestNode.neighbors[j]]);
        }
    }

    return graph[t].d;
}

int main() {
    int N = 0, M = 0, S = 0, T = 0;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T;
    Node* graph = new Node[N + 1];
    for (int i = 0; i &lt; N + 1; i++)
        graph[i].id = i;
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        graph[a].neighbors.push_back(b);
        graph[a].edges.push_back(edge);
        graph[b].neighbors.push_back(a);
        graph[b].edges.push_back(edge);
    }

    cout &lt;&lt; dijkstra(graph, N, S, T) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
