<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hihocoder | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/hihocoder/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-12T18:12:23+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1038 - 01背包]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-01-package/"/>
    <updated>2016-05-12T17:57:15+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-01-package</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>经典01背包问题。给定有限空间M，N件物品，每件物品对应体积C及价值V，求最大能获得的价值总和。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1038">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>动态规划。递推式为：<br/>
<code>f[i, j] = max(f[i-1, j-C[i]] + V[i], f[i-1, j])</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为MN，空间复杂度为2M，进一步可优化为M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxValue(int* needs, int* values, int N, int M) {
    int** V = new int*[2];
    for (int i = 0; i &lt; 2; i++)
        V[i] = new int[M + 1];

    for (int i = 0; i &lt; M + 1; i++)
        V[0][i] = 0;
    int curLine = 1;
    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; M + 1; j++) {
            if (needs[i] &lt;= j)
                V[curLine][j] = max(V[1 - curLine][j - needs[i]] + values[i], V[1 - curLine][j]);
            else
                V[curLine][j] = V[1 - curLine][j];
        }
        curLine = 1 - curLine;
    }

    int maxV = V[1 - curLine][M];

    for (int i = 0; i &lt; 2; i++)
        delete[] V[i];
    delete[] V;

    return maxV;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    int *needs = new int[N], *values = new int[N];
    for (int i = 0; i &lt; N; i++)
        cin &gt;&gt; needs[i] &gt;&gt; values[i];

    cout &lt;&lt; maxValue(needs, values, N, M) &lt;&lt; endl;

    delete[] needs, values;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1037 - 数字三角形]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-number-triangle/"/>
    <updated>2016-05-12T17:32:59+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-number-triangle</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>一个三角形的n层迷宫，第i层有i个格子，每个格子里有一些礼品，第i层编号为j的格子可以通向第i+1层编号为j、j+1的格子。通道是单向的。求问从第1层第一个格子开始，一直走到迷宫最高层，最多能获得多少礼品。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1037">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>很简单的动态规划。递推式：<br/>
<code>f[i+1, j] = max(f[i, j-1], f[i, j]) + V[i+1, j]</code></p>

<h2>时间复杂度</h2>

<p>时间复杂度为N<sup>2</sup>，空间复杂度为1（因为输入数据的矩阵维度与需要计算的一致）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int maxA(int** A, int n) {
    for (int i = 1; i &lt; n; i++) {
        A[i][0] = A[i - 1][0] + A[i][0];
        for (int j = 1; j &lt;= i; j++)
            A[i][j] = max(A[i - 1][j - 1], A[i - 1][j]) + A[i][j];
    }

    int maxV = 0;
    for (int i = 0; i &lt; n; i++)
        maxV = max(maxV, A[n - 1][i]);

    return maxV;
}

int main() {
    int n = 0;
    cin &gt;&gt; n;
    int** A = new int*[n];
    for (int i = 0; i &lt; n; i++)
        A[i] = new int[n];
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt;= i; j++)
            cin &gt;&gt; A[i][j];

    cout &lt;&lt; maxA(A, n) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1032 - 最长回文子串]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/12/hihocoder-longest-palindromic-substring/"/>
    <updated>2016-05-12T16:04:46+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/12/hihocoder-longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>回文串定义为从左往右及从右往左是完全一样的字符串。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1032">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>直接暴力搜索复杂度为N<sup>2</sup>。因为是求子串而非子序列，所以动态规划的思路也不可行。考虑对搜索过程进行优化：<br/>
首先仅考虑长度为奇数的子串，那么以字符串中任意一个字符为中心搜索其最长的回文子串（利用对称）。<br/>
其次考虑可利用的现有信息。如下：<br/>
<code>caabaacd</code><br/>
假设目前已知f[4] = 7，f[5] = 1，求f[6]，我们可以发现，由于f[4] = 7，字符串[5, 7]和[3, 1]是完全相等的，即如果[1, 3]是回文子串，那么[5, 7]也是回文子串。这也就意味着如果f[2] &lt; 3，那么f[6] = f[2]；如果f[2] >= 3，那么f[6] >= 3（注意2是6以4为中心的对称坐标）。假设每次在求第i个位置为中心的最长回文子串时，我们已知能达到最右端点P的是以第j个位置为中心的最长回文子串，其右端点为j + f[j]/2，这样我们可以得到一个下述关系：<br/>
<code>f[i] &gt;= min(f[2j-i], f[2j-2i+f[j])</code><br/>
这样每次搜索时可以省去很多冗余搜索。<br/>
最后一个问题是怎么将上述方法推广到求偶数长度的回文子串。只需要在原字符串的基础上每两个相邻字符间插入一个特殊字符，那么原字符串的最长回文子串一定对应着新串的一个奇数最长回文子串。</p>

<h2>时间复杂度</h2>

<p>每一步里如果f[2j-i] &lt; 2j-2i+f[j]那么f[i] = f[2j-i]，否则我们以i为中心进行扩展，此时要么最大右边界P不移动；要么最大右边界P会往右移动，最多N次。总共2N次操作。时间复杂度为2N。（参考<a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii/">Longest Palindromic Substring Part II</a>）</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

int longestPalSubStr(string str) {
    string modStr = "";
    modStr += str[0];
    for (int i = 1; i &lt; str.size(); i++) {
        modStr += '$';
        modStr += str[i];
    }

    int maxL = 0;
    int* f = new int[modStr.size()];
    for (int i = 0; i &lt; modStr.size(); i++)
        f[i] = 1;
    int maxBorder = 0;
    for (int i = 0; i &lt; modStr.size(); i++) {
        int minL = min(f[2 * maxBorder - i], f[maxBorder] - 2 * (i - maxBorder));
        f[i] = minL &gt; 0 ? minL : 0;
        for (int j = (minL - 1) / 2 + 1; i - j &gt;= 0 &amp;&amp; i + j &lt; modStr.size(); j++) {
            if (modStr[i + j] != modStr[i - j])
                break;
            f[i] += 2;
        }
        maxBorder = f[i] / 2 + i &gt; f[maxBorder] / 2 + maxBorder ? i : maxBorder;
        maxL = max(maxL, i % 2 == 1 ? (f[i] + 1) / 4 * 2 : (f[i] - 1) / 4 * 2 + 1 );
    }

    return maxL;
} 

int main() {
    int N = 0; 
    cin &gt;&gt; N;
    for (int i = 0; i &lt; N; i++) {
        string str;
        cin &gt;&gt; str;

        cout &lt;&lt; longestPalSubStr(str) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1015 - KMP算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/11/hihocoder-kmp/"/>
    <updated>2016-05-11T19:27:36+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/11/hihocoder-kmp</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>经典的模式字符串匹配问题。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1015">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>KMP算法主要利用了在一次匹配失败后收集信息，选取下一个起始点进行重新匹配，省去了大量冗余比较。<br/>
首先，考察下述例子：<br/>
<code>原串：  bababa</code><br/>
<code>模式串：bababb</code><br/>
我们给出两个标记，j是原串上当前遍历到的位置，i是模式串上当前遍历到的位置，那么可以发现一个性质：假设当前在模式串的i+1位置发生了不匹配，而且满足模式串[1, t]与[i-t+1, i]相等的最大的t为k，那么只有将模式串至少前进k-1才可能发生匹配，且只需要从原串上当前位置j，以及模式串上位置k+1继续比较。这个模式字符串的不同位置对应的k被称为next数组。<br/>
暴力求解next数组将会是M<sup>2</sup>的时间复杂度，仔细思考可以发现求解next数组本身也可以利用上述想法。假设当前已经求出next[i]，我们可以考虑原串[1, i+1]与模式串[1, i]的匹配过程，可以发现最后求得的模式串匹配点即是next[i+1]。因此可以用递归的形式求解next数组。</p>

<h2>时间复杂度</h2>

<p>首先考虑每次i++的情况，进行一次比较，共n次；其次考虑i不变的情况，j=next[j]，模式串是永远往右移动的，最多n次。因此时间复杂度为N，加上计算next数组，时间复杂度为N + M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void calNext(string str, int idx, int* next) {
    if (idx &gt; str.size())
        return;

    int q = next[idx - 1];
    while (q != -1) {
        if (str[q] == str[idx - 1]) {
            next[idx] = q + 1;
            break;
        }
        q = next[q];
    }
    if (q == -1)
        next[idx] = 0;
    calNext(str, idx + 1, next);
}

int kmp(string str, string pattern) {
    // resolve the NEXT array
    int* next = new int[pattern.size() + 1];
    next[0] = -1;
    calNext(pattern, 1, next);

    // pattern match
    int m = 0;
    int i = 0, j = 0;
    for (; i &lt; str.size();) {
        if (j == -1) {
            i++;
            j = 0;
            continue;
        }
        int k = j;
        for (; k &lt; pattern.size(); k++)
            if (str[i + k - j] != pattern[k])
                break;
        if (k == pattern.size())
            m++;
        i += k - j;
        j = next[k];
    }

    return m;
}

int main() {
    int N = 0;
    cin &gt;&gt; N;
    for (int i = 0; i &lt; N; i++) {
        string pattern, str;
        cin &gt;&gt; pattern &gt;&gt; str;

        cout &lt;&lt; kmp(str, pattern) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1014 - Trie树]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/11/hihocoder-trie/"/>
    <updated>2016-05-11T18:05:08+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/11/hihocoder-trie</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>Trie树就是字典树。对于一个给定的词典，任给一个字符串，输出词典中以该字符串为前缀的单词数目。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1014">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>在建立Trie树的同时我们就可以着手统计以某个字符串为前缀的节点个数，即每次添加一个新单词的时候，沿途更新所有经过的节点。</p>

<h2>时间复杂度</h2>

<p>单词查询用时26M（M：查询字符串的长度），单次插入用时26M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

struct Node {
    int L = 1;
    char ch = ' ';
    vector&lt;Node*&gt; successors;

    Node(char c) {
        ch = c;
    }
};

class Trie {
private:
    Node* root;

    void updatePrefix(Node* node, string word, int idx) {
        if (idx == word.size())
            return;

        bool find = false;
        for (int i = 0; i &lt; node-&gt;successors.size(); i++) {
            if (node-&gt;successors[i]-&gt;ch == word[idx]) {
                find = true;
                node-&gt;successors[i]-&gt;L++;
                updatePrefix(node-&gt;successors[i], word, idx + 1);
                break;
            }
        }

        if (!find) {
            for (int i = idx; i &lt; word.size(); i++) {
                node-&gt;successors.push_back(new Node(word[i]));
                node = node-&gt;successors.back();
            }
        }
    }

    int findPrefix(Node* node, string query, int idx) {
        for (int i = 0; i &lt; node-&gt;successors.size(); i++) {
            if (node-&gt;successors[i]-&gt;ch == query[idx]) {
                if (idx == query.size() - 1)
                    return node-&gt;successors[i]-&gt;L;

                return findPrefix(node-&gt;successors[i], query, idx + 1);
            }
        }

        return 0;
    }

    void deleteTrie(Node* node) {
        for (int i = 0; i &lt; node-&gt;successors.size(); i++)
            deleteTrie(node-&gt;successors[i]);
        delete node;
    }

public:
    Trie() {
        root = new Node('$');
    }

    ~Trie() {
        deleteTrie(root);
    }

    void insert(string word) {
        updatePrefix(root, word, 0);
    }

    int getStat(string query) {
        return findPrefix(root, query, 0);
    }
};

int main() {
    int n = 0;
    cin &gt;&gt; n;
    string* words = new string[n];
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; words[i];
    int m = 0;
    cin &gt;&gt; m;
    string* queries = new string[m];
    for (int i = 0; i &lt; m; i++)
        cin &gt;&gt; queries[i];

    Trie trie;
    for (int i = 0; i &lt; n; i++)
        trie.insert(words[i]);

    for (int i = 0; i &lt; m; i++)
        cout &lt;&lt; trie.getStat(queries[i]) &lt;&lt; endl;

    delete[] words, queries;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
