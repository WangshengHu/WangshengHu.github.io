<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-16T21:05:03+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1098 - Kruskal算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-kruscal/"/>
    <updated>2016-05-16T20:24:40+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-kruscal</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，求最小生成树。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1098">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典的Kruskal算法。<br/>
1. 对图中的边以非降序排列；<br/>
2. 对排好序的每条边，如果加入最小生成树不会形成环（采用<a href="/blog/2016/05/15/hihocoder-union-set/">Union-Find Set</a>实现），则加入最小生成树。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为MlogM。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Edge {
    int a = 0;
    int b = 0;
    int length = 0;
};

class FindUnionSet {
private:
    int N;
    int* nodes;

public:
    FindUnionSet(int N) {
        nodes = new int[N + 1];
        for (int i = 1; i &lt;= N; i++)
            nodes[i] = i;
    }

    ~FindUnionSet() {
        delete[] nodes;
    }

    int find(int node) {
        if (nodes[node] == node)
            return node;
        nodes[node] = find(nodes[node]);
        return nodes[node];
    }

    void unionset(int a, int b) {
        nodes[find(nodes[a])] = find(nodes[b]);
    }
};

bool edgesCmp(const Edge&amp; a, const Edge&amp; b) {
    return a.length &lt; b.length;
}

int kruskal(vector&lt;Edge&gt; edges, int N, int M) {
    sort(edges.begin(), edges.end(), edgesCmp);
    FindUnionSet set = FindUnionSet(N);
    int minCost = 0;
    int i = 0;
    int k = 0;
    while (i &lt; N - 1) {
        if (set.find(edges[k].a) != set.find(edges[k].b)) {
            set.unionset(edges[k].a, edges[k].b);
            minCost += edges[k].length;
            i++;
        }
        k++;
    }

    return minCost;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N &gt;&gt; M;
    vector&lt;Edge&gt; edges = vector&lt;Edge&gt;(M);
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        edges[i].a = a;
        edges[i].b = b;
        edges[i].length = edge;
    }

    cout &lt;&lt; kruskal(edges, N, M) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1093 - SPFA算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-spfa/"/>
    <updated>2016-05-16T19:12:45+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-spfa</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，两个顶点之间可能有多条边，求顶点1到顶点N的最短路径。给定的图中边的数量较少。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1093">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>SPFA算法，即Shortest Path Faster Algorithm。对图进行广度优先搜索，并且在搜索的过程中实时更新所有顶点到顶点1的最短距离。具体来说，是在一个顶点出队时查看它的所有邻接顶点，并更新它们的最短距离，如果它们不在队列中则入队。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为O(kE)，k是个比较小的系数（并且在绝大多数的图中，k&lt;=2，然而在一些精心构造的图中可能会上升到很高）（摘自<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95">维基百科</a>）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct Node {
    int d = -1;
    bool inQueue = false;
    vector&lt;Node*&gt; neighbors;
    vector&lt;int&gt; edges;
};

int spfa(Node* graph, int s, int t) {
    Node* S = graph + s;
    S-&gt;d = 0;
    queue&lt;Node*&gt; queue;
    queue.push(S);
    while (!queue.empty()) {
        Node* cur = queue.front();
        cur-&gt;inQueue = false;
        queue.pop();
        for (int i = 0; i &lt; cur-&gt;neighbors.size(); i++) {
            if (cur-&gt;neighbors[i]-&gt;d == -1 || cur-&gt;neighbors[i]-&gt;d &gt; cur-&gt;d + cur-&gt;edges[i]) {
                cur-&gt;neighbors[i]-&gt;d = cur-&gt;d + cur-&gt;edges[i];
                if (!cur-&gt;neighbors[i]-&gt;inQueue) {
                    cur-&gt;neighbors[i]-&gt;inQueue = true;
                    queue.push(cur-&gt;neighbors[i]);
                }
            }
        }
    }

    return graph[t].d;
}

int main() {
    int N = 0, M = 0, S = 0, T = 0;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T;
    Node* graph = new Node[N + 1];
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        graph[a].neighbors.push_back(graph + b);
        graph[a].edges.push_back(edge);
        graph[b].neighbors.push_back(graph + a);
        graph[b].edges.push_back(edge);
    }

    cout &lt;&lt; spfa(graph, S, T) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1081 - 最短路径·一]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-dijkstra/"/>
    <updated>2016-05-16T17:21:52+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-dijkstra</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个无向图，两个顶点之间可能有多条边，求顶点1到顶点N的最短路径。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1081">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>经典Dijkstra算法。<br/>
1. 初始化集合X和Y，X = {1}, Y = V - {1}；<br/>
2. 对顶点1的所有相邻顶点，更新d[i] = 边长；否则d[i] = 无穷大；<br/>
3. 从Y中选取一个d最小的顶点v，将v从Y中删除并加入X，更新所有与v相邻顶点的d。<br/>
注意我在实现时采用了C++ STL的priority_queue结构。由于priority_queue不提供随机访问的功能（即获取其中一个元素的具体位置）这样会导致第3步中每次更新时都要进行一次入队操作。</p>

<h2>时间复杂度</h2>

<p>朴素的实现是N<sup>2</sup>，如果采用堆实现的话可以减小到MlogN。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
using namespace std;

struct Node {
    int id = -1;
    int d = -1;
    vector&lt;int&gt; neighbors;
    vector&lt;int&gt; edges;
};

struct NodeCmp {
    bool operator()(const Node &amp;a, const Node &amp;b) const {
        return b.d &lt; a.d;
    }
};

int dijkstra(Node* graph, int N, int s, int t) {
    bitset&lt;1001&gt; set;
    set.reset();
    priority_queue&lt;Node, vector&lt;Node&gt;, NodeCmp&gt; heap;
    graph[s].d = 0;
    set[s] = 1;
    for (int i = 0; i &lt; graph[s].neighbors.size(); i++) {
        graph[graph[s].neighbors[i]].d = graph[s].edges[i];
        heap.push(graph[graph[s].neighbors[i]]);
    }

    int i = 0;
    while (i &lt; N - 1) {
        Node nearestNode = heap.top();
        heap.pop();
        if (set[nearestNode.id])
            continue;
        i++;
        set[nearestNode.id] = 1;
        for (int j = 0; j &lt; nearestNode.neighbors.size(); j++) {
            if (graph[nearestNode.neighbors[j]].d == -1 || nearestNode.edges[j] + nearestNode.d &lt; graph[nearestNode.neighbors[j]].d)
                graph[nearestNode.neighbors[j]].d = nearestNode.edges[j] + nearestNode.d;
            heap.push(graph[nearestNode.neighbors[j]]);
        }
    }

    return graph[t].d;
}

int main() {
    int N = 0, M = 0, S = 0, T = 0;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T;
    Node* graph = new Node[N + 1];
    for (int i = 0; i &lt; N + 1; i++)
        graph[i].id = i;
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0, edge = 0;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; edge;
        graph[a].neighbors.push_back(b);
        graph[a].edges.push_back(edge);
        graph[b].neighbors.push_back(a);
        graph[b].edges.push_back(edge);
    }

    cout &lt;&lt; dijkstra(graph, N, S, T) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1069 - 最近公共祖先·三]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-lowest-common-ancestor-3/"/>
    <updated>2016-05-16T15:40:40+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-lowest-common-ancestor-3</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定N对节点之间的继承关系（一个节点仅有一个父节点），给定任意两个节点，求它们的最近公共祖先节点。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1069">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>这次用到的算法称为在线算法，与<a href="/blog/2016/05/15/hihocoder-lowest-common-ancestor-2/">离线算法</a>相对应。关键在于将树转换为数组进行求解。<br/>
对树进行深度优先搜索，每次经过一个点时（无论是从父节点进来还是从子节点回来）都按顺序记录下来（<strong>实际上只需要记录每一次从子节点回来即可</strong>），得到的数组中，任意两个节点的最近公共祖先就是这两个节点在数组中的位置所包含起来的那一段区间中深度最小的那个点。这样就成功将问题转换成了<a href="/blog/2016/05/16/hihocoder-rmq-st/">RMQ-ST问题</a>。</p>

<h2>时间复杂度</h2>

<p>DFS的时间复杂度是N，RMQ-ST算法时间复杂度是NlogN，共M次询问，则整体时间复杂度为NlogN + M + N。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MAX_SIZE = 100000;

struct Node {
    string name;
    int level = 0;
    vector&lt;Node*&gt; children;

    Node(string n): name(n) {}
};

void dfs(Node* root, vector&lt;Node*&gt;&amp; vec) {
    for (int i = 0; i &lt; root-&gt;children.size(); i++) {
        root-&gt;children[i]-&gt;level = root-&gt;level + 1;
        dfs(root-&gt;children[i], vec);
        vec.push_back(root);
    }
    if (root-&gt;children.size() == 0)
        vec.push_back(root);
}

unordered_map&lt;string, int&gt; names;
Node* M[MAX_SIZE][32];
void rmqSt(Node* root) {
    vector&lt;Node*&gt; vec;
    dfs(root, vec);

    int N = vec.size();
    for (int i = 0; i &lt; N; i++)
        names[vec[i]-&gt;name] = i;

    int p = -1;
    int n = N;
    while (n &gt; 0) {
        n &gt;&gt;= 1;
        p++;
    }
    for (int i = 0; i &lt; N; i++)
        M[i][0] = vec[i];
    for (int i = 1; i &lt;= p; i++) {
        for (int j = 0; j &lt; N; j++) {
            if (j + (1 &lt;&lt; i - 1) &lt; N)
                M[j][i] = M[j][i - 1]-&gt;level &lt; M[j + (1 &lt;&lt; i - 1)][i - 1]-&gt;level ? M[j][i - 1] : M[j + (1 &lt;&lt; i - 1)][i - 1];
            else
                M[j][i] = M[j][i - 1];
        }
    }
}

string find(string a, string b) {
    int l = names[a], r = names[b];
    if (l &gt; r) {
        int tmp = l;
        l = r;
        r = tmp;
    }
    int p = -1;
    int n = r - l + 1;
    while (n &gt; 0) {
        n &gt;&gt;= 1;
        p++;
    }
    Node* ancestor = M[l][p]-&gt;level &lt; M[r - (1 &lt;&lt; p) + 1][p]-&gt;level ? M[l][p] : M[r - (1 &lt;&lt; p) + 1][p];
    return ancestor-&gt;name;
}

int main() {
    int N = 0, M = 0;
    cin &gt;&gt; N;
    unordered_map&lt;string, Node*&gt; family;
    string father, son;
    cin &gt;&gt; father &gt;&gt; son;
    Node* root = new Node(father);
    root-&gt;level = 0;
    family[son] = new Node(son);
    root-&gt;children.push_back(family[son]);
    family[father] = root;
    for (int i = 1; i &lt; N; i++) {
        cin &gt;&gt; father &gt;&gt; son;
        if (family.find(father) == family.end())
            family[father] = new Node(father);
        family[son] = new Node(son);
        family[father]-&gt;children.push_back(family[son]);
    }

    rmqSt(root);

    cin &gt;&gt; M;
    for (int i = 0; i &lt; M; i++) {
        string a, b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; find(a, b) &lt;&lt; endl;
    }

    for (auto it = family.begin(); it != family.end(); it++)
        delete it-&gt;second;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1068 - RMQ-ST算法]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/16/hihocoder-rmq-st/"/>
    <updated>2016-05-16T15:21:26+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/16/hihocoder-rmq-st</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定N个数字，标号为从1到N，有Q次询问，每次求一个区间[L, R]里最小的数字。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1068">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>直接暴力搜索的话时间复杂度是NQ，对N和Q都很大的情况不适用。RMQ-ST算法的核心思想是对数据进行预处理，对每一个位置i，预先计算所有[i, 2<sup>j</sup>]（0&lt;=j&lt;=logN+1）的最小值，那么对任一个询问[L, R]，答案就是min([L, T], [R-T+1, T])（T为小于[L, R]区间长度的最大的2的整数次幂）。<br/>
而对每一个位置i计算[i, 2<sup>j</sup>]的过程可以采用动态规划。递推式为：
<code>m[i, j] = min(m[i, j-1], m[i+2^(j-1), j-1])</code></p>

<h2>时间复杂度</h2>

<p>每次询问用时1，预处理时，对每个位置都要进行计算，计算耗时logN，时间复杂度恰为NlogN。因此整体时间复杂度为NlogN + Q。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MAX_SIZE = 1000001;

int M[MAX_SIZE][32] = { {0} };
void rmqSt(int* W, int N) {
    int p = -1;
    int n = N;
    while (n &gt; 0) {
        n &gt;&gt;= 1;
        p++;
    }
    for (int i = 1; i &lt;= N; i++)
        M[i][0] = W[i];
    for (int i = 1; i &lt;= p; i++)
        for (int j = 1; j &lt;= N; j++) {
            if (j + (1 &lt;&lt; i - 1) &lt;= N)
                M[j][i] = min(M[j][i - 1], M[j + (1 &lt;&lt; i - 1)][i - 1]);
            else
                M[j][i] = M[j][i - 1];
        }
}

int find(int L, int R) {
    int p = -1;
    int l = R - L + 1;
    while (l &gt; 0) {
        l &gt;&gt;= 1;
        p++;
    }
    return min(M[L][p], M[R - (1 &lt;&lt; p) + 1][p]);
}

int main() {
    int N = 0, Q = 0;
    scanf_s("%d", &amp;N);
    int* W = new int[N + 1];
    for (int i = 1; i &lt;= N; i++)
        scanf_s("%d", W + i);

    rmqSt(W, N);

    scanf_s("%d", &amp;Q);
    for (int i = 1; i &lt;= Q; i++) {
        int l = 0, r = 0;
        scanf_s("%d", &amp;l);
        scanf_s("%d", &amp;r);
        printf("%d\n", find(l, r));
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
