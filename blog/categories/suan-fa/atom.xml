<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-11T17:58:44+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1296 - 数论三·约瑟夫问题]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/11/hihocoder-josephus/"/>
    <updated>2016-05-11T13:41:29+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/11/hihocoder-josephus</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>N个人围成一个圈，编号为0&hellip;N-1，随机一个数字K，从0号开始按从1到K的顺序报数，报到K的人出局，下一个人从1开始，依此循环。最后留下的人为胜者。求胜者的编号。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1296">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>此题是著名的约瑟夫（Josephus）问题，直接暴力解的话时间复杂度是MN。考虑递推关系，可以得到f[n] = (f[n-1] + K) mod n。具体证明如下：<br/>
假设n个人排好序：<br/>
<code>0 1 2 3 ... n-1</code><br/>
此时先执行第一遍报数，将位置T（(K-1) mod n）的人去掉，剩下的人排序：<br/>
<code>0 1 2 ... T-1, T+1, T+2, ... n-1</code><br/>
问题转换为从T+1开始，N-1个人的约瑟夫问题，此时胜者的编号应该为(f[n-1] + T+1) mod n，即(f[n-1] + K) mod n。证毕。<br/>
此时时间复杂度为N，但仍可进行改进。每一次递减的幅度可以更大，比如N=10，K=4：<br/>
<code>0 1 2 3 4 5 6 7 8 9</code><br/>
遍历一遍，经过两轮报数，剩下的序列是：<br/>
<code>0 1 2 - 4 5 6 -8 9</code><br/>
此时仍然可以用地推关系求解，从f[10]到f[8]，不过递推关系修改如下：
<code>
f[n - n/K] &lt; n mod K: f[n] = f[n - n/K] - n mod K + n
f[n - n/K] &gt;= n mod K: f[n] = f[n - n/K] - n mod K + (f[n - n/K] - n mod K)/(K - 1)（遍历完一遍后余下的序列不连续）
</code>
注意当K > n之后问题回归到最开始的解法。</p>

<h2>时间复杂度</h2>

<p>修改过后的算法时间复杂度为log<sub>K</sub>N + K。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

int josephus(int n, int k) {
    if (n == 1)
        return 0;

    int ret = 0;
    if (n &lt; k) {
        for (int i = 2; i &lt;= n; i++)
            ret = (ret + k) % i;
        return ret;
    }

    ret = josephus(n - n / k, k);
    if (ret &lt; n % k)
        ret = ret - n % k + n;
    else
        ret = ret - n % k + (ret - n % k) / (k - 1);

    return ret;
}

int main() {
    int t = 0;
    cin &gt;&gt; t;
    for (int i = 0; i &lt; t; i++) {
        int n = 0, k = 0;
        cin &gt;&gt; n &gt;&gt; k;

        cout &lt;&lt; josephus(n, k) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1272 - 买零食]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/11/hihocoder-buy-snack/"/>
    <updated>2016-05-11T12:23:11+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/11/hihocoder-buy-snack</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>小卖部中有许多种零食，每种零食都有渴望度，且价格小数部分仅可能为0.5或0。一次只能买三包以内的零食，且价格必须是5的整数倍，求能买到的最大渴望度。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1272">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>动态规划。递推式：S[i,j,k] = max(S[i-1,j-1,k-m] + s[i], S[i-1,j,k])，其中i代表零食编号，j代表购买数量，k代表总价格乘2模10。m代表s[i]x2 mod 10。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为4x10xN，空间复杂度为4x10xN，空间复杂度可优化成4x10x2，更进一步可优化成4x10x1（考虑到递推关系中每次变化仅相差1）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int mod(float p) {
    return (int) (p * 2) % 10;
}

int maxSat(float *A, int *B, int N) {
    int ***S = new int**[N];
    for (int i = 0; i &lt; N; i++) {
        S[i] = new int*[4];
        for (int j = 0; j &lt; 4; j++) {
            S[i][j] = new int[10];
            for (int k = 0; k &lt; 10; k++)
                S[i][j][k] = -1;
            S[i][0][0] = 0;
        }
    }

    S[0][1][mod(A[0])] = B[0];
    for (int i = 1; i &lt; N; i++) {
        for (int j = 1; j &lt; 4; j++) {
            for (int k = 0; k &lt; 10; k++) {
                int m = (k - mod(A[i]) + 10) % 10;
                if (S[i - 1][j - 1][m] != -1)
                    S[i][j][k] = S[i - 1][j - 1][m] + B[i];
                if (S[i - 1][j][k] != -1)
                    S[i][j][k] = max(S[i][j][k], S[i - 1][j][k]);
            }
        }
    }

    int maxS = 0;
    for (int i = 0; i &lt; 4; i++)
        maxS = max(maxS, S[N - 1][i][0]);

    for (int i = 1; i &lt; N; i++) {
        for (int j = 1; j &lt; 4; j++)
            delete[] S[i][j];
        delete[] S[i];
    }
    delete[] S;

    return maxS;
}

int main() {
    int Q = 0;
    cin &gt;&gt; Q;
    for (int i = 0; i &lt; Q; i++) {
        int N = 0;
        cin &gt;&gt; N;
        float *A = new float[N];
        int *B = new int[N];
        for (int j = 0; j &lt; N; j++)
            cin &gt;&gt; A[j] &gt;&gt; B[j];

        cout &lt;&lt; maxSat(A, B, N) &lt;&lt; endl;

        delete[] A, B;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1268 - 九宫]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-magic-square/"/>
    <updated>2016-05-10T19:59:36+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-magic-square</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个残缺的三阶幻方，判断是否只有一组可行解，如果只有一组可行解，打印之。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1268">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>对给定的残缺三阶幻方，首先可以通过行列斜之和为15尽可能进行补全；如果只有一种解，那一定可以填满9个数字，除了一种情况：“十字架”形。对“十字架”刑，实际上也只可能有一种解，可以根据已填数字推算出整个幻方。</p>

<h2>时间复杂度</h2>

<p>为常数。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

bool check(int *square) {
    int filled = 0;
    for (int i = 0; i &lt; 9; i++)
        filled += (square[i] != 0);
    int lastFilled = 0;
    do {
        lastFilled = filled;
        if (square[4] == 0) {
            square[4] = 5;
            filled++;
        }
        int state = (square[0] != 0) + (square[8] != 0);
        if (state == 1) {
            square[square[0] != 0 ? 8 : 0] = 10 - square[0] - square[8];
            filled++;
        }
        state = (square[1] != 0) + (square[7] != 0);
        if (state == 1) {
            square[square[1] != 0 ? 7 : 1] = 10 - square[1] - square[7];
            filled++;
        }
        state = (square[2] != 0) + (square[6] != 0);
        if (state == 1) {
            square[square[2] != 0 ? 6 : 2] = 10 - square[2] - square[6];
            filled++;
        }
        state = (square[3] != 0) + (square[5] != 0);
        if (state == 1) {
            square[square[3] != 0 ? 5 : 3] = 10 - square[3] - square[5];
            filled++;
        }

        state = (square[0] != 0) + (square[1] != 0) + (square[2] != 0);
        if (state == 2) {
            square[(square[1] == 0) + (square[2] == 0) * 2] = 15 - square[0] - square[1] - square[2];
            filled++;
        }
        state = (square[2] != 0) + (square[5] != 0) + (square[8] != 0);
        if (state == 2) {
            square[(square[2] == 0) * 2 + (square[5] == 0) * 5 + (square[8] == 0) * 8] = 15 - square[2] - square[5] - square[8];
            filled++;
        }
        state = (square[8] != 0) + (square[7] != 0) + (square[6] != 0);
        if (state == 2) {
            square[(square[8] == 0) * 8 + (square[7] == 0) * 7 + (square[6] == 0) * 6] = 15 - square[8] - square[7] - square[6];
            filled++;
        }
        state = (square[6] != 0) + (square[3] != 0) + (square[0] != 0);
        if (state == 2) {
            square[(square[6] == 0) * 6 + (square[3] == 0) * 3] = 15 - square[6] - square[3] - square[0];
            filled++;
        }

        state = (square[1] != 0) + (square[7] != 0) + (square[3] != 0) + (square[5] != 0) + (square[4] != 0);
        int state1 = (square[0] == 0) + (square[2] == 0) + (square[6] == 0) + (square[8] == 0);
        if (state == 5 &amp;&amp; state1 == 4) {
            if ((square[1] == 9 &amp;&amp; square[3] == 3) || (square[1] == 3 &amp;&amp; square[3] == 9)) {
                square[0] = 4;
                filled++;
            }
            else if ((square[1] == 9 &amp;&amp; square[3] == 7) || (square[1] == 7 &amp;&amp; square[3] == 9)) {
                square[0] = 2;
                filled++;
            }
            else if ((square[1] == 1 &amp;&amp; square[3] == 3) || (square[1] == 3 &amp;&amp; square[3] == 1)) {
                square[0] = 8;
                filled++;
            }
            else if ((square[1] == 1 &amp;&amp; square[3] == 7) || (square[1] == 7 &amp;&amp; square[3] == 1)) {
                square[0] = 6;
                filled++;
            }
        }
    } while (lastFilled != filled);

    return (filled == 9);
}

int main() {
    int *square = new int[9];
    for (int i = 0; i &lt; 9; i++)
        cin &gt;&gt; square[i];

    if (check(square))
        cout &lt;&lt; square[0] &lt;&lt; " " &lt;&lt; square[1] &lt;&lt; " " &lt;&lt; square[2] &lt;&lt; endl &lt;&lt; square[3] &lt;&lt; " "
        &lt;&lt; square[4] &lt;&lt; " " &lt;&lt; square[5] &lt;&lt; endl &lt;&lt; square[6] &lt;&lt; " " &lt;&lt; square[7] &lt;&lt; " "
        &lt;&lt; square[8] &lt;&lt; endl;
    else
        cout &lt;&lt; "Too Many" &lt;&lt; endl;

    delete[] square;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1223 - 不等式]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-inequation/"/>
    <updated>2016-05-10T19:37:28+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-inequation</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定n个关于X的不等式，最多有多少个成立。不等式形如X &lt; C，X &lt;= C，X = C， X > C, X >= C。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1223">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>想像在一个数轴上从左到右扫描，对任意不等式X &lt; C，在C左边时其成立，到C时其不成立；对X &lt;= C， 过了C其不成立；对X = C，到C成立，过C不成立；对X > C，过了C成立；对X >= C，到C成立。因此对任意一个C，我们采用两个标记<code>intOp</code>和<code>decOp</code>，<code>intOp</code>表示扫描到C点的执行操作，<code>decOP</code>表示扫描过C点的执行操作。<br/>
起始时我们统计所有&lt;及&lt;=关系，并将其设为初始可满足不等式数；然后按C的递增序遍历所有不等式，并分别就到达C点及走过C点执行相应操作，计算当前可满足不等式数；最后统计最大可满足数。</p>

<h2>时间复杂度</h2>

<p>由于遍历一遍所有不等式，时间复杂度为N。需要注意我们要对输入不等式进行排序，因此时间复杂度为NlogN（实际实现中采用了C++ STL的map，自动排序）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Number {
    int intOp = 0;
    int decOp = 0;

    Number(int eq, int ineq) {
        intOp = eq;
        decOp = ineq;
    }
};

int calMax(map&lt;int, Number&gt; numbers, int init) {
    int maxVal = init;
    int curVal = init;
    for (auto it = numbers.begin(); it != numbers.end(); it++) {
        curVal += it-&gt;second.intOp;
        maxVal = max(maxVal, curVal);
        curVal += it-&gt;second.decOp;
        maxVal = max(maxVal, curVal);
    }

    return maxVal;
}

bool process(string op, int c, map&lt;int, Number&gt; &amp;numbers) {
    bool less = false;
    int intOp = 0, decOp = 0;
    if (op == "&lt;") {
        intOp = -1;
        less = true;
    }
    else if (op == "&lt;=") {
        decOp = -1; 
        less = true;
    }
    else if (op == "=") {
        intOp = 1;
        decOp = -1;
    }
    else if (op == "&gt;=")
        intOp = 1;
    else if (op == "&gt;")
        decOp = 1;

    if (numbers.find(c) != numbers.end()) {
        numbers.find(c)-&gt;second.intOp += intOp;
        numbers.find(c)-&gt;second.decOp += decOp;
    }
    else
        numbers.insert(make_pair(c, Number(intOp, decOp)));

    return less;
}

int main() {
    int N = 0;
    cin &gt;&gt; N;
    map&lt;int, Number&gt; numbers;
    int init = 0;
    for (int i = 0; i &lt; N; i++) {
        char x;
        string op;
        int c;
        cin &gt;&gt; x &gt;&gt; op &gt;&gt; c;
        init += process(op, c, numbers)? 1 : 0;
    }

    cout &lt;&lt; calMax(numbers, init) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1175 - 拓扑排序·二]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-topology-sort/"/>
    <updated>2016-05-10T17:45:11+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-topology-sort</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个有向无环图，在任意个节点上投放“病毒”，“病毒”会沿着有向边传播。计算最终该图中总共有多少“病毒”。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1175">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>因为是有向无环图，可以找到一个“起始点”，该点入度为0。从该点出发进行广度优先搜索，该点处理完后可以直接从图中移除。依次重复此操作。</p>

<h2>时间复杂度</h2>

<p>每个节点入队一次，每条边遍历依次，时间复杂度为N + M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct Vertex {
    int sum = 0;
    int degree = 0;
    vector&lt;int&gt; neighbors;
};

int calSum(vector&lt;Vertex&gt; A) {
    queue&lt;int&gt; queue;

    for (int i = 0; i &lt; A.size(); i++)
        if (A[i].degree == 0)
            queue.push(i);

    int sum = 0;
    do {
        int root = queue.front();
        queue.pop();
        int curSum = A[root].sum;
        sum += curSum % 142857;
        sum %= 142857;
        vector&lt;int&gt; &amp;neighbors = A[root].neighbors;
        for (int i = 0; i &lt; neighbors.size(); i++) {
            A[neighbors[i]].sum += curSum;
            A[neighbors[i]].sum %= 142857;
            A[neighbors[i]].degree--;
            if (A[neighbors[i]].degree == 0)
                queue.push(neighbors[i]);
        }
    } while (!queue.empty());

    return sum;
}

int main() {
    int N = 0, M = 0, K = 0;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;
    vector&lt;Vertex&gt; A = vector&lt;Vertex&gt;(N);
    for (int i = 0; i &lt; K; i++) {
        int a = 0;
        cin &gt;&gt; a;
        A[a - 1].sum++;
    }
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0;
        cin &gt;&gt; a &gt;&gt; b;
        A[a - 1].neighbors.push_back(b - 1);
        A[b - 1].degree++;
    }

    cout &lt;&lt; calSum(A);

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
