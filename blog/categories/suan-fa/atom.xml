<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-10T17:03:19+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder - 2月29日]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-leap-year/"/>
    <updated>2016-05-10T16:55:41+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-leap-year</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定两个日期，计算这两个日期之间有多少个2月29日（包括起始日期）。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1148">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>先简化问题，简化起始、终止年份，然后分情况讨论即可。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为1。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

unordered_map&lt;string, int&gt; months;

int getMonth(string str) {
    return months[str];
}

int calYears(int start, int end) {
    if (start == end) {
        if (start % 4 == 0)
            if (start % 100 != 0 || start % 400 == 0)
                return 1;

        return 0;
    }

    int start1 = start;
    while (start1 % 4 != 0)
        start1++;
    int start2 = start1;
    while (start2 % 100 != 0)
        start2 += 4;
    int start3 = start2;
    while (start3 % 400 != 0)
        start3 += 100;

    int end1 = end;
    while (end1 % 4 != 0)
        end1--;
    int end2 = end1;
    while (end2 % 100 != 0)
        end2 -= 4;
    int end3 = end2;
    while (end3 % 400 != 0)
        end3 -= 100;

    int num1 = 0;
    if (end1 - start1 &lt; 0)
        return 0;
    num1 = (end1 - start1) / 4 + 1;

    int num2 = 0;
    if (end2 - start2 &lt; 0)
        num2 = 0;
    num2 = (end2 - start2) / 100 + 1;

    int num3 = 0;
    if (end3 - start3 &lt; 0)
        num3 = 0;
    num3 = (end3 - start3) / 400 + 1;

    return num1 - num2 + num3;
}

int processStr(string mon, int day, int year, bool start) {
    int month = months[mon];
    if (start) {
        if (month &lt; 2 || (month == 2 &amp;&amp; day &lt;= 29))
            return year;

        return year + 1;
    }
    else {
        if (month &gt; 2 || (month == 2 &amp;&amp; day == 29))
            return year;

        return year - 1;
    }
}

int main() {
    months["January"] = 1;
    months["February"] = 2;
    months["March"] = 3;
    months["April"] = 4;
    months["May"] = 5;
    months["June"] = 6;
    months["July"] = 7;
    months["August"] = 8;
    months["September"] = 9;
    months["October"] = 10;
    months["November"] = 11;
    months["December"] = 12;

    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        string month;
        int day;
        string comma;
        int year;
        cin &gt;&gt; month &gt;&gt; day &gt;&gt; comma &gt;&gt; year;
        int start = processStr(month, day, year, true);
        cin &gt;&gt; month &gt;&gt; day &gt;&gt; comma &gt;&gt; year;
        int end = processStr(month, day, year, false);

        cout &lt;&lt; "Case #" &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; calYears(start, end) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1143 - 骨牌覆盖问题·一]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-gupaifugaiwenti-1/"/>
    <updated>2016-05-10T15:44:00+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-gupaifugaiwenti-1</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>一个2xN的棋盘，用1x2的骨牌进行覆盖，一共有多少种不同的覆盖方法。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1143">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>动态规划，F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>。即斐波那契数列。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为N（可以用快速幂算法缩减到logN），空间复杂度为1。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

int fib(int N) {
    int f0 = 0, f1 = 1;
    for (int i = 0; i &lt; N; i++) {
        int tmp = f1;
        f1 = (f0 + f1) % 19999997;
        f0 = tmp;
    }

    return f1;
}

int main() {
    int N = 0;
    cin &gt;&gt; N;

    cout &lt;&lt; fib(N) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1138 - Islands Travel]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-islands-travel/"/>
    <updated>2016-05-10T15:13:21+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-islands-travel</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定N个节点，坐标分别为(X<sub>1</sub>, Y<sub>1</sub>),&hellip;(X<sub>N</sub>, Y<sub>N</sub>)，任意两点之间的距离定义为min{|X<sub>i</sub> - X<sub>j</sub>|, |Y<sub>i</sub>| - Y<sub>j</sub>}，求X<sub>1</sub>到X<sub>N</sub>的最短距离。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1138">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>本题如果采用暴力解法，直接计算出所有点对距离然后采用Dijkstra或者SPFA是不行的，因为这是一个完全图，光是计算所有点对间的距离时间复杂度就已经是N<sup>2</sup>了。因此需要优化Dijkstra算法的输入数据。采用数学知识进行分析，可以发现对任意一个点，我们只需要考虑x轴上一左一右离它最近的两个点，以及y轴上一上一下离它最近的两个点。这样一来边数就从N<sup>2</sup>减到了4N，采用堆实现的Dijkstra即可。</p>

<h2>时间复杂度</h2>

<p>堆实现的Dijkstra的时间复杂度为MlogN，其中M = 4N，所以时间复杂度为NlogN。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;

struct Node {
    int id = -1;
    int d = -1;
    vector&lt;int&gt; neighbors;
    vector&lt;int&gt; edges;
};

struct NodeCmp {
    bool operator()(const Node &amp;a, const Node &amp;b) const {
        return b.d &lt; a.d;
    }
};

int dijkstra(Node* graph, int N, int s, int t) {
    bitset&lt;100001&gt; set;
    set.reset();
    priority_queue&lt;Node, vector&lt;Node&gt;, NodeCmp&gt; heap;
    graph[s].d = 0;
    set[s] = 1;
    for (int i = 0; i &lt; graph[s].neighbors.size(); i++) {
        graph[graph[s].neighbors[i]].d = graph[s].edges[i];
        heap.push(graph[graph[s].neighbors[i]]);
    }

    int i = 0;
    while (i &lt; N - 1) {
        Node nearestNode = heap.top();
        heap.pop();
        if (set[nearestNode.id])
            continue;
        i++;
        set[nearestNode.id] = 1;
        for (int j = 0; j &lt; nearestNode.neighbors.size(); j++) {
            if (graph[nearestNode.neighbors[j]].d == -1 || nearestNode.edges[j] + nearestNode.d &lt; graph[nearestNode.neighbors[j]].d)
                graph[nearestNode.neighbors[j]].d = nearestNode.edges[j] + nearestNode.d;
            heap.push(graph[nearestNode.neighbors[j]]);
        }
    }

    return graph[t].d;
}

struct Point {
    int id = 0;
    int x = 0;
    int y = 0;
    Point(int i, int xv, int yv) {
        id = i;
        x = xv;
        y = yv;
    }
};

bool xComp(const Point &amp;a, const Point &amp;b) {
    return a.x &lt; b.x;
}

bool yComp(const Point &amp;a, const Point &amp;b) {
    return a.y &lt; b.y;
}

int main() {
    int N = 0;
    cin &gt;&gt; N;
    vector&lt;Point&gt; coord;
    for (int i = 1; i &lt; N + 1; i++) {
        int x = 0, y = 0;
        cin &gt;&gt; x &gt;&gt; y;
        coord.push_back(Point(i, x, y));
    }
    Node* graph = new Node[N + 1];
    for (int i = 0; i &lt; N + 1; i++)
        graph[i].id = i;
    sort(coord.begin(), coord.end(), xComp);
    for (int i = 0; i &lt; N - 1; i++) {
        int a = coord[i].id;
        int b = coord[i + 1].id;
        int edge = min(abs(coord[i].x - coord[i + 1].x), abs(coord[i].y - coord[i + 1].y));
        graph[a].neighbors.push_back(b);
        graph[a].edges.push_back(edge);
        graph[b].neighbors.push_back(a);
        graph[b].edges.push_back(edge);
    }
    sort(coord.begin(), coord.end(), yComp);
    for (int i = 0; i &lt; N - 1; i++) {
        int a = coord[i].id;
        int b = coord[i + 1].id;
        int edge = min(abs(coord[i].x - coord[i + 1].x), abs(coord[i].y - coord[i + 1].y));
        graph[a].neighbors.push_back(b);
        graph[a].edges.push_back(edge);
        graph[b].neighbors.push_back(a);
        graph[b].edges.push_back(edge);
    }

    cout &lt;&lt; dijkstra(graph, N, 1, N) &lt;&lt; endl;

    return 0;
}
</code></pre>

<h2>问题</h2>

<ol>
<li>上述代码堆的实现直接使用了C++ STL里的<code>priority_queue</code>，它的数据类型不能是指针。</li>
<li>每次<code>priority_queue</code>进队时都会调用<code>Node</code>结构体的复制构造器，在<code>Node</code>结构体复杂的时候很耗时，应尽量降低<code>Node</code>结构体的复杂度。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HihoCoder#1135 - Magic Box]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-magic-box/"/>
    <updated>2016-05-10T12:03:52+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-magic-box</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>一个Magic Box，不断往里放三种颜色的球（红色R，黄色Y，蓝色B），一旦这三种球数目之差为x，y，z（无序），则所有球消失。给定一个放球的序列，求盒子中球最多时刻球的数目。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1135">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>直接暴力解。</p>

<h2>时间复杂度</h2>

<p>给定序列循环一遍，时间复杂度为N。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
using namespace std;

int maxLen(string seq, int x, int y, int z) {
    int max = 0;
    int len = 0;
    int r = 0, g = 0, b = 0;
    for (int i = 0; i &lt; seq.size(); i++) {
        if (seq[i] == 'R')
            r++;
        else if (seq[i] == 'B')
            g++;
        else if (seq[i] == 'Y')
            b++;
        len++;
        if ((abs(r - g) == x &amp;&amp; abs(g - b) == y &amp;&amp; abs(b - r) == z) ||
            (abs(r - g) == x &amp;&amp; abs(b - r) == y &amp;&amp; abs(g - b) == z) ||
            (abs(g - b) == x &amp;&amp; abs(r - g) == y &amp;&amp; abs(b - r) == z) ||
            (abs(g - b) == x &amp;&amp; abs(b - r) == y &amp;&amp; abs(r - g) == z) ||
            (abs(b - r) == x &amp;&amp; abs(g - b) == y &amp;&amp; abs(r - g) == z) ||
            (abs(b - r) == x &amp;&amp; abs(r - g) == y &amp;&amp; abs(g - b) == z)) {
            r = 0;
            g = 0;
            b = 0;
            if (max &lt; len)
                max = len;
            len = 0;
        }
    }

    if (max &lt; len)
        max = len;

    return max;
}

int main() {
    int x = 0, y = 0, z = 0;
    string charSeq;
    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    cin &gt;&gt; charSeq;
    cout &lt;&lt; maxLen(charSeq, x, y, z);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1121 - 二分图一·二分图判定]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/08/hihocoder-bipartite-graph-1/"/>
    <updated>2016-05-08T14:30:14+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/08/hihocoder-bipartite-graph-1</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>判定是否存在一个合理的染色方案，使得我们所建立的无向图满足每一条边两端的顶点颜色都不相同。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1121">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>广度优先搜素（采用栈实现），首先任选一个未染色节点进行染色，并将其所有邻居节点染不同色，然后对每个邻居节点重复此操作。如果发现某一时刻一个节点与其邻居节点同色，则返回假；否则遍历完所有节点，返回真。</p>

<h2>时间复杂度</h2>

<p>由于每个节点入栈一次，每条边检查两次，时间复杂度为N + M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct Vertex {
    int color = -1;
    vector&lt;int&gt; neighbors;
};

bool check(Vertex *graph, int N) {
    int root = 1;
    do {
        queue&lt;int&gt; visited;
        visited.push(root);
        graph[root].color = 0;
        while (!visited.empty()) {
            int root = visited.front();
            visited.pop();
            vector&lt;int&gt; neighbors = graph[root].neighbors;
            for (int i = 0; i &lt; neighbors.size(); i++) {
                if (graph[neighbors[i]].color == -1) {
                    graph[neighbors[i]].color = 1 - graph[root].color;
                    visited.push(neighbors[i]);
                }
                else if (graph[neighbors[i]].color == graph[root].color)
                    return false;
            }
        }

        root = 0;
        for (int i = 1; i &lt; N + 1; i++)
            if (graph[i].color == -1) {
                root = i;
                break;
            }
    } while (root != 0);

    return true;
}

int main() {
    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        int N = 0, M = 0;
        cin &gt;&gt; N &gt;&gt; M;
        Vertex *graph = new Vertex[N + 1];
        for (int j = 0; j &lt; M; j++) {
            int a = 0, b = 0;
            cin &gt;&gt; a &gt;&gt; b;
            graph[a].neighbors.push_back(b);
            graph[b].neighbors.push_back(a);
        }

        cout &lt;&lt; (check(graph, N) ? "Correct" : "Wrong") &lt;&lt; endl;

        delete[] graph;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
