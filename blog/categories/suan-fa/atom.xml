<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | Lost & Found]]></title>
  <link href="http://wangshenghu.github.io/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://wangshenghu.github.io/"/>
  <updated>2016-05-10T20:16:30+08:00</updated>
  <id>http://wangshenghu.github.io/</id>
  <author>
    <name><![CDATA[WangshengHu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1268 - 九宫]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-magic-square/"/>
    <updated>2016-05-10T19:59:36+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-magic-square</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个残缺的三阶幻方，判断是否只有一组可行解，如果只有一组可行解，打印之。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1268">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>对给定的残缺三阶幻方，首先可以通过行列斜之和为15尽可能进行补全；如果只有一种解，那一定可以填满9个数字，除了一种情况：“十字架”形。对“十字架”刑，实际上也只可能有一种解，可以根据已填数字推算出整个幻方。</p>

<h2>时间复杂度</h2>

<p>为常数。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

bool check(int *square) {
    int filled = 0;
    for (int i = 0; i &lt; 9; i++)
        filled += (square[i] != 0);
    int lastFilled = 0;
    do {
        lastFilled = filled;
        if (square[4] == 0) {
            square[4] = 5;
            filled++;
        }
        int state = (square[0] != 0) + (square[8] != 0);
        if (state == 1) {
            square[square[0] != 0 ? 8 : 0] = 10 - square[0] - square[8];
            filled++;
        }
        state = (square[1] != 0) + (square[7] != 0);
        if (state == 1) {
            square[square[1] != 0 ? 7 : 1] = 10 - square[1] - square[7];
            filled++;
        }
        state = (square[2] != 0) + (square[6] != 0);
        if (state == 1) {
            square[square[2] != 0 ? 6 : 2] = 10 - square[2] - square[6];
            filled++;
        }
        state = (square[3] != 0) + (square[5] != 0);
        if (state == 1) {
            square[square[3] != 0 ? 5 : 3] = 10 - square[3] - square[5];
            filled++;
        }

        state = (square[0] != 0) + (square[1] != 0) + (square[2] != 0);
        if (state == 2) {
            square[(square[1] == 0) + (square[2] == 0) * 2] = 15 - square[0] - square[1] - square[2];
            filled++;
        }
        state = (square[2] != 0) + (square[5] != 0) + (square[8] != 0);
        if (state == 2) {
            square[(square[2] == 0) * 2 + (square[5] == 0) * 5 + (square[8] == 0) * 8] = 15 - square[2] - square[5] - square[8];
            filled++;
        }
        state = (square[8] != 0) + (square[7] != 0) + (square[6] != 0);
        if (state == 2) {
            square[(square[8] == 0) * 8 + (square[7] == 0) * 7 + (square[6] == 0) * 6] = 15 - square[8] - square[7] - square[6];
            filled++;
        }
        state = (square[6] != 0) + (square[3] != 0) + (square[0] != 0);
        if (state == 2) {
            square[(square[6] == 0) * 6 + (square[3] == 0) * 3] = 15 - square[6] - square[3] - square[0];
            filled++;
        }

        state = (square[1] != 0) + (square[7] != 0) + (square[3] != 0) + (square[5] != 0) + (square[4] != 0);
        int state1 = (square[0] == 0) + (square[2] == 0) + (square[6] == 0) + (square[8] == 0);
        if (state == 5 &amp;&amp; state1 == 4) {
            if ((square[1] == 9 &amp;&amp; square[3] == 3) || (square[1] == 3 &amp;&amp; square[3] == 9)) {
                square[0] = 4;
                filled++;
            }
            else if ((square[1] == 9 &amp;&amp; square[3] == 7) || (square[1] == 7 &amp;&amp; square[3] == 9)) {
                square[0] = 2;
                filled++;
            }
            else if ((square[1] == 1 &amp;&amp; square[3] == 3) || (square[1] == 3 &amp;&amp; square[3] == 1)) {
                square[0] = 8;
                filled++;
            }
            else if ((square[1] == 1 &amp;&amp; square[3] == 7) || (square[1] == 7 &amp;&amp; square[3] == 1)) {
                square[0] = 6;
                filled++;
            }
        }
    } while (lastFilled != filled);

    return (filled == 9);
}

int main() {
    int *square = new int[9];
    for (int i = 0; i &lt; 9; i++)
        cin &gt;&gt; square[i];

    if (check(square))
        cout &lt;&lt; square[0] &lt;&lt; " " &lt;&lt; square[1] &lt;&lt; " " &lt;&lt; square[2] &lt;&lt; endl &lt;&lt; square[3] &lt;&lt; " "
        &lt;&lt; square[4] &lt;&lt; " " &lt;&lt; square[5] &lt;&lt; endl &lt;&lt; square[6] &lt;&lt; " " &lt;&lt; square[7] &lt;&lt; " "
        &lt;&lt; square[8] &lt;&lt; endl;
    else
        cout &lt;&lt; "Too Many" &lt;&lt; endl;

    delete[] square;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1223 - 不等式]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-inequation/"/>
    <updated>2016-05-10T19:37:28+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-inequation</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定n个关于X的不等式，最多有多少个成立。不等式形如X &lt; C，X &lt;= C，X = C， X > C, X >= C。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1223">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>想像在一个数轴上从左到右扫描，对任意不等式X &lt; C，在C左边时其成立，到C时其不成立；对X &lt;= C， 过了C其不成立；对X = C，到C成立，过C不成立；对X > C，过了C成立；对X >= C，到C成立。因此对任意一个C，我们采用两个标记<code>intOp</code>和<code>decOp</code>，<code>intOp</code>表示扫描到C点的执行操作，<code>decOP</code>表示扫描过C点的执行操作。<br/>
起始时我们统计所有&lt;及&lt;=关系，并将其设为初始可满足不等式数；然后按C的递增序遍历所有不等式，并分别就到达C点及走过C点执行相应操作，计算当前可满足不等式数；最后统计最大可满足数。</p>

<h2>时间复杂度</h2>

<p>由于遍历一遍所有不等式，时间复杂度为N。需要注意我们要对输入不等式进行排序，因此时间复杂度为NlogN（实际实现中采用了C++ STL的map，自动排序）。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Number {
    int intOp = 0;
    int decOp = 0;

    Number(int eq, int ineq) {
        intOp = eq;
        decOp = ineq;
    }
};

int calMax(map&lt;int, Number&gt; numbers, int init) {
    int maxVal = init;
    int curVal = init;
    for (auto it = numbers.begin(); it != numbers.end(); it++) {
        curVal += it-&gt;second.intOp;
        maxVal = max(maxVal, curVal);
        curVal += it-&gt;second.decOp;
        maxVal = max(maxVal, curVal);
    }

    return maxVal;
}

bool process(string op, int c, map&lt;int, Number&gt; &amp;numbers) {
    bool less = false;
    int intOp = 0, decOp = 0;
    if (op == "&lt;") {
        intOp = -1;
        less = true;
    }
    else if (op == "&lt;=") {
        decOp = -1; 
        less = true;
    }
    else if (op == "=") {
        intOp = 1;
        decOp = -1;
    }
    else if (op == "&gt;=")
        intOp = 1;
    else if (op == "&gt;")
        decOp = 1;

    if (numbers.find(c) != numbers.end()) {
        numbers.find(c)-&gt;second.intOp += intOp;
        numbers.find(c)-&gt;second.decOp += decOp;
    }
    else
        numbers.insert(make_pair(c, Number(intOp, decOp)));

    return less;
}

int main() {
    int N = 0;
    cin &gt;&gt; N;
    map&lt;int, Number&gt; numbers;
    int init = 0;
    for (int i = 0; i &lt; N; i++) {
        char x;
        string op;
        int c;
        cin &gt;&gt; x &gt;&gt; op &gt;&gt; c;
        init += process(op, c, numbers)? 1 : 0;
    }

    cout &lt;&lt; calMax(numbers, init) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1175 - 拓扑排序·二]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-topology-sort/"/>
    <updated>2016-05-10T17:45:11+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-topology-sort</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定一个有向无环图，在任意个节点上投放“病毒”，“病毒”会沿着有向边传播。计算最终该图中总共有多少“病毒”。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1175">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>因为是有向无环图，可以找到一个“起始点”，该点入度为0。从该点出发进行广度优先搜索，该点处理完后可以直接从图中移除。依次重复此操作。</p>

<h2>时间复杂度</h2>

<p>每个节点入队一次，每条边遍历依次，时间复杂度为N + M。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

struct Vertex {
    int sum = 0;
    int degree = 0;
    vector&lt;int&gt; neighbors;
};

int calSum(vector&lt;Vertex&gt; A) {
    queue&lt;int&gt; queue;

    for (int i = 0; i &lt; A.size(); i++)
        if (A[i].degree == 0)
            queue.push(i);

    int sum = 0;
    do {
        int root = queue.front();
        queue.pop();
        int curSum = A[root].sum;
        sum += curSum % 142857;
        sum %= 142857;
        vector&lt;int&gt; &amp;neighbors = A[root].neighbors;
        for (int i = 0; i &lt; neighbors.size(); i++) {
            A[neighbors[i]].sum += curSum;
            A[neighbors[i]].sum %= 142857;
            A[neighbors[i]].degree--;
            if (A[neighbors[i]].degree == 0)
                queue.push(neighbors[i]);
        }
    } while (!queue.empty());

    return sum;
}

int main() {
    int N = 0, M = 0, K = 0;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;
    vector&lt;Vertex&gt; A = vector&lt;Vertex&gt;(N);
    for (int i = 0; i &lt; K; i++) {
        int a = 0;
        cin &gt;&gt; a;
        A[a - 1].sum++;
    }
    for (int i = 0; i &lt; M; i++) {
        int a = 0, b = 0;
        cin &gt;&gt; a &gt;&gt; b;
        A[a - 1].neighbors.push_back(b - 1);
        A[b - 1].degree++;
    }

    cout &lt;&lt; calSum(A);

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder#1152 - Lucky Substrings]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-lucky-substrings/"/>
    <updated>2016-05-10T17:37:44+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-lucky-substrings</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>如果一个字符串的所有不同字符数量是一个斐波那契数，那它就是一个Lucky String。给定一个仅包含小写字母的字符串，按字典序输出其所有非空的Lucky Subtring。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1152">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>暴力搜索。</p>

<h2>时间复杂度</h2>

<p>遍历一遍字符串，对每个字符又要进行一次遍历，时间复杂度为N<sup>2</sup>。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
using namespace std;

set&lt;string&gt; luckySubstr(string str) {
    set&lt;string&gt; substrs;
    int fib[] = { 1, 2, 3, 5, 8, 13, 21 };
    for (int i = 0; i &lt; str.size(); i++) {
        set&lt;char&gt; chars;
        string curstr = "";
        for (int j = i; j &lt; str.size(); j++) {
            curstr += str[j];
            if (chars.find(str[j]) == chars.end())
                chars.insert(str[j]);

            for (int k = 0; k &lt; 7; k++)
                if (fib[k] == chars.size())
                    substrs.insert(curstr);
        }
    }

    return substrs;
}

int main() {
    string str;
    cin &gt;&gt; str;

    set&lt;string&gt; substrs = luckySubstr(str);
    for (auto it = substrs.begin(); it != substrs.end(); it++)
        cout &lt;&lt; it-&gt;data() &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hihoCoder - 2月29日]]></title>
    <link href="http://wangshenghu.github.io/blog/2016/05/10/hihocoder-leap-year/"/>
    <updated>2016-05-10T16:55:41+08:00</updated>
    <id>http://wangshenghu.github.io/blog/2016/05/10/hihocoder-leap-year</id>
    <content type="html"><![CDATA[<h2>题目</h2>

<p>给定两个日期，计算这两个日期之间有多少个2月29日（包括起始日期）。<br/>
具体描述请见<a href="http://hihocoder.com/problemset/problem/1148">hihoCoder</a>。</p>

<!--more-->


<h2>解题思路</h2>

<p>先简化问题，简化起始、终止年份，然后分情况讨论即可。</p>

<h2>时间复杂度</h2>

<p>时间复杂度为1。</p>

<h2>代码</h2>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

unordered_map&lt;string, int&gt; months;

int getMonth(string str) {
    return months[str];
}

int calYears(int start, int end) {
    if (start == end) {
        if (start % 4 == 0)
            if (start % 100 != 0 || start % 400 == 0)
                return 1;

        return 0;
    }

    int start1 = start;
    while (start1 % 4 != 0)
        start1++;
    int start2 = start1;
    while (start2 % 100 != 0)
        start2 += 4;
    int start3 = start2;
    while (start3 % 400 != 0)
        start3 += 100;

    int end1 = end;
    while (end1 % 4 != 0)
        end1--;
    int end2 = end1;
    while (end2 % 100 != 0)
        end2 -= 4;
    int end3 = end2;
    while (end3 % 400 != 0)
        end3 -= 100;

    int num1 = 0;
    if (end1 - start1 &lt; 0)
        return 0;
    num1 = (end1 - start1) / 4 + 1;

    int num2 = 0;
    if (end2 - start2 &lt; 0)
        num2 = 0;
    num2 = (end2 - start2) / 100 + 1;

    int num3 = 0;
    if (end3 - start3 &lt; 0)
        num3 = 0;
    num3 = (end3 - start3) / 400 + 1;

    return num1 - num2 + num3;
}

int processStr(string mon, int day, int year, bool start) {
    int month = months[mon];
    if (start) {
        if (month &lt; 2 || (month == 2 &amp;&amp; day &lt;= 29))
            return year;

        return year + 1;
    }
    else {
        if (month &gt; 2 || (month == 2 &amp;&amp; day == 29))
            return year;

        return year - 1;
    }
}

int main() {
    months["January"] = 1;
    months["February"] = 2;
    months["March"] = 3;
    months["April"] = 4;
    months["May"] = 5;
    months["June"] = 6;
    months["July"] = 7;
    months["August"] = 8;
    months["September"] = 9;
    months["October"] = 10;
    months["November"] = 11;
    months["December"] = 12;

    int T = 0;
    cin &gt;&gt; T;
    for (int i = 0; i &lt; T; i++) {
        string month;
        int day;
        string comma;
        int year;
        cin &gt;&gt; month &gt;&gt; day &gt;&gt; comma &gt;&gt; year;
        int start = processStr(month, day, year, true);
        cin &gt;&gt; month &gt;&gt; day &gt;&gt; comma &gt;&gt; year;
        int end = processStr(month, day, year, false);

        cout &lt;&lt; "Case #" &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; calYears(start, end) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
